{"version":3,"sources":["../src/Diagnostics.js"],"names":["logger","Diagnostics","constructor","flow","diagnoseOne","document","emptyDiagnostic","uri","diagnostics","documentPath","getDiagnostics","buffer","size","Array","from","entries","map","fileDiagnosticUpdateToLSPDiagnostic","observe","info","observeDiagnostics","filePath","flowDiagnostics","filter","d","range","diagnostic","relatedLocations","trace","atomTrace_lspRelatedLocation","severity","type","source","providerName","relatedInformation","message","length","toMessage","text","location","toUpperCase"],"mappings":"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","file":"Diagnostics.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {PublishDiagnosticsParams} from 'vscode-languageserver';\nimport type {DiagnosticMessage, DiagnosticTrace} from 'atom-ide-ui';\nimport type TextDocument from './TextDocument';\nimport type {Observable} from 'rxjs';\n\nimport {arrayCompact} from 'nuclide-commons/collection';\nimport {FlowSingleProjectLanguageService} from './pkg/nuclide-flow-rpc/lib/FlowSingleProjectLanguageService';\nimport {\n  atomRangeToLSPRange,\n  flowSeverityToLSPSeverity,\n  fileURIToPath,\n  filePathToURI,\n} from './utils/util';\nimport {getLogger} from 'log4js';\nimport invariant from 'assert';\n\nconst logger = getLogger('Diagnostics');\n\ntype DiagnosticsParams = {\n  flow: FlowSingleProjectLanguageService,\n};\n\nexport default class Diagnostics {\n  flow: FlowSingleProjectLanguageService;\n\n  constructor({flow}: DiagnosticsParams) {\n    this.flow = flow;\n  }\n\n  async diagnoseOne(\n    document: TextDocument,\n  ): Promise<Array<PublishDiagnosticsParams>> {\n    const emptyDiagnostic = {\n      uri: document.uri,\n      diagnostics: [],\n    };\n\n    const documentPath = fileURIToPath(document.uri);\n    if (!documentPath) {\n      return [];\n    }\n\n    const diagnostics = await this.flow.getDiagnostics(\n      documentPath,\n      document.buffer,\n    );\n\n    if (diagnostics == null || diagnostics.size === 0) {\n      // clear out any old diagnostics by sending an explicit empty list of\n      // diagnostics\n      return [emptyDiagnostic];\n    }\n\n    return Array.from(diagnostics.entries()).map(\n      fileDiagnosticUpdateToLSPDiagnostic,\n    );\n  }\n\n  observe(): Observable<Array<PublishDiagnosticsParams>> {\n    logger.info('Beginning to observe diagnostics');\n\n    return this.flow.observeDiagnostics().map(diagnostics =>\n      Array.from(diagnostics.entries()).map(\n        // $FlowFixMe\n        fileDiagnosticUpdateToLSPDiagnostic,\n      ),\n    );\n  }\n}\n\nfunction fileDiagnosticUpdateToLSPDiagnostic([filePath, flowDiagnostics]: [\n  string,\n  Array<DiagnosticMessage>,\n]): PublishDiagnosticsParams {\n  return {\n    uri: filePathToURI(filePath),\n    diagnostics: flowDiagnostics\n      .filter(d => d.range != null)\n      .map(diagnostic => {\n        const relatedLocations = arrayCompact(\n          (diagnostic.trace || []).map(atomTrace_lspRelatedLocation),\n        );\n\n        invariant(diagnostic.range != null);\n        return {\n          range: atomRangeToLSPRange(diagnostic.range),\n          severity: flowSeverityToLSPSeverity(diagnostic.type),\n          source: diagnostic.providerName,\n          relatedInformation: relatedLocations,\n          message:\n            relatedLocations.length === 0\n              ? toMessage(diagnostic)\n              : diagnostic.text || '',\n        };\n      }),\n  };\n}\n\n/**\n * From Nuclide's convert.js\n *\n * Converts an Atom Trace to an Lsp RelatedLocation. A RelatedLocation requires a\n * range. Therefore, this will return null when called with an Atom Trace that\n * does not have a range.\n */\nfunction atomTrace_lspRelatedLocation(trace: DiagnosticTrace): ?Object {\n  const {range, text, filePath} = trace;\n  if (range != null) {\n    return {\n      message: text || '',\n      location: {\n        uri: filePathToURI(filePath),\n        range: atomRangeToLSPRange(range),\n      },\n    };\n  }\n  return null;\n}\n\n// transform legacy diagnostics (without relatedLocations) into a more verbose\n// description\nfunction toMessage(diagnostic: DiagnosticMessage): string {\n  let message = diagnostic.text || '';\n  if (diagnostic.trace && diagnostic.trace.length) {\n    for (const trace of diagnostic.trace) {\n      if (trace.text != null) {\n        // put new 'sentences' on their own line\n        // $FlowFixMe text presence is asserted above\n        if (trace.text[0] && trace.text[0] === trace.text[0].toUpperCase()) {\n          message += '\\n';\n        } else {\n          message += ' ';\n        }\n        message += trace.text;\n      }\n    }\n  }\n\n  return message;\n}\n"]}