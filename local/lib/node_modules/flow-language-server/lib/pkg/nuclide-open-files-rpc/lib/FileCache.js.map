{"version":3,"sources":["../../../../src/pkg/nuclide-open-files-rpc/lib/FileCache.js"],"names":["FileCache","constructor","_buffers","Map","_fileEvents","_directoryEvents","Set","_requests","_resources","add","update","updateBufferAndMakeEventFunc","event","onEvent","kind","getBufferForFileEvent","next","onFileEvent","filePath","fileVersion","changeCount","version","fileInfo","get","buffer","OPEN","_open","contents","languageId","CLOSE","_close","EDIT","getTextInRange","oldRange","oldText","setTextInRange","newText","SAVE","_save","SYNC","_syncEdit","Error","Promise","resolve","undefined","getTotalBufferSize","addLength","acc","getText","length","values","reduce","onDirectoriesChanged","openDirectories","getRange","setText","newRange","createEditEvent","createFileVersion","newBuffer","set","createOpenEvent","delete","createCloseEvent","destroy","createSaveEvent","dispose","entries","size","complete","getBuffer","getBufferAtVersion","waitForBufferAtVersion","fileEvent","isBufferAtVersion","getOpenDirectories","getValue","getContainingDirectory","dir","contains","getOpenFiles","keys","observeFileEvents","from","Array","map","concat","observeDirectoryEvents","notifier"],"mappings":"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","file":"FileCache.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {\n  FileOpenEvent,\n  FileCloseEvent,\n  FileEditEvent,\n  FileSaveEvent,\n  FileEvent,\n  FileVersion,\n  LocalFileEvent,\n} from './rpc-types';\n\nimport TextBuffer from 'simple-text-buffer';\nimport invariant from 'assert';\nimport {BehaviorSubject, Subject, Observable} from 'rxjs';\nimport {FileVersionNotifier} from './FileVersionNotifier';\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\nimport nuclideUri from 'nuclide-commons/nuclideUri';\n\nimport {FileEventKind} from './constants';\n\n/**\n * NB: although it is possible to change the language ID after the file has\n * already been opened, the file cache will not update to reflect that.\n */\nexport class FileCache {\n  _buffers: Map<\n    NuclideUri,\n    {buffer: simpleTextBuffer$TextBuffer, languageId: string},\n  >;\n\n  _requests: FileVersionNotifier;\n  _fileEvents: Subject<LocalFileEvent>;\n  // Care! update() is the only way you're allowed to update _buffers or _requests\n  // or to fire a _fileEvents.next() event. That's to ensure that the three things\n  // stay in sync.\n  _directoryEvents: BehaviorSubject<Set<NuclideUri>>;\n  _resources: UniversalDisposable;\n\n  constructor() {\n    this._buffers = new Map();\n    this._fileEvents = new Subject();\n    this._directoryEvents = new BehaviorSubject(new Set());\n    this._requests = new FileVersionNotifier();\n\n    this._resources = new UniversalDisposable();\n    this._resources.add(this._requests);\n  }\n\n  update(updateBufferAndMakeEventFunc: () => LocalFileEvent) {\n    const event = updateBufferAndMakeEventFunc();\n    this._requests.onEvent(event);\n\n    // invariant: because the above two lines have updated both _buffers and _requests,\n    // then getBufferAtVersion will necessarily return immediately and successfully.\n    // And getBufferForFileEvent will also succeed.\n    invariant(event.kind !== 'edit' || this.getBufferForFileEvent(event));\n\n    this._fileEvents.next(event);\n  }\n\n  // If any out of sync state is detected then an Error is thrown.\n  // This will force the client to send a 'sync' event to get back on track.\n  onFileEvent(event: FileEvent): Promise<void> {\n    const filePath = event.fileVersion.filePath;\n    const changeCount = event.fileVersion.version;\n    const fileInfo = this._buffers.get(filePath);\n    const buffer = fileInfo != null ? fileInfo.buffer : null;\n    switch (event.kind) {\n      case FileEventKind.OPEN:\n        invariant(buffer == null);\n        this._open(filePath, event.contents, changeCount, event.languageId);\n        break;\n      case FileEventKind.CLOSE:\n        if (buffer != null) {\n          this._close(filePath, buffer);\n        }\n        break;\n      case FileEventKind.EDIT:\n        invariant(buffer != null);\n        invariant(buffer.changeCount === changeCount - 1);\n        invariant(buffer.getTextInRange(event.oldRange) === event.oldText);\n        this.update(() => {\n          buffer.setTextInRange(event.oldRange, event.newText);\n          invariant(buffer.changeCount === changeCount);\n          return event;\n        });\n        break;\n      case FileEventKind.SAVE:\n        this._save(filePath, changeCount);\n        break;\n      case FileEventKind.SYNC:\n        if (buffer == null) {\n          this._open(filePath, event.contents, changeCount, event.languageId);\n        } else {\n          this._syncEdit(filePath, buffer, event.contents, changeCount);\n        }\n        break;\n      default:\n        (event.kind: empty);\n        throw new Error(`Unexpected FileEvent.kind: ${event.kind}`);\n    }\n    return Promise.resolve(undefined);\n  }\n\n  async getTotalBufferSize(): Promise<number> {\n    const addLength = (acc, {buffer}) => acc + buffer.getText().length;\n    return [...this._buffers.values()].reduce(addLength, 0);\n  }\n\n  async onDirectoriesChanged(openDirectories: Set<NuclideUri>): Promise<void> {\n    this._directoryEvents.next(openDirectories);\n  }\n\n  _syncEdit(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    contents: string,\n    changeCount: number,\n  ): void {\n    // messages are out of order\n    if (changeCount < buffer.changeCount) {\n      return;\n    }\n\n    const oldText = buffer.getText();\n    const oldRange = buffer.getRange();\n    this.update(() => {\n      buffer.setText(contents);\n      const newRange = buffer.getRange();\n      buffer.changeCount = changeCount;\n      return createEditEvent(\n        this.createFileVersion(filePath, changeCount),\n        oldRange,\n        oldText,\n        newRange,\n        buffer.getText(),\n      );\n    });\n  }\n\n  _open(\n    filePath: NuclideUri,\n    contents: string,\n    changeCount: number,\n    languageId: string,\n  ): void {\n    // We never call setPath on these TextBuffers as that will\n    // start the TextBuffer attempting to sync with the file system.\n    const newBuffer = new TextBuffer(contents);\n    newBuffer.changeCount = changeCount;\n    this.update(() => {\n      this._buffers.set(filePath, {buffer: newBuffer, languageId});\n      return createOpenEvent(\n        this.createFileVersion(filePath, changeCount),\n        contents,\n        languageId,\n      );\n    });\n  }\n\n  _close(filePath: NuclideUri, buffer: simpleTextBuffer$TextBuffer): void {\n    this.update(() => {\n      this._buffers.delete(filePath);\n      return createCloseEvent(\n        this.createFileVersion(filePath, buffer.changeCount),\n      );\n    });\n    buffer.destroy();\n  }\n\n  _save(filePath: NuclideUri, changeCount: number): void {\n    this.update(() => {\n      return createSaveEvent(this.createFileVersion(filePath, changeCount));\n    });\n  }\n\n  dispose(): void {\n    // The _close routine will delete elements from the _buffers map.\n    // Per ES6 this is safe to do even while iterating.\n    for (const [filePath, {buffer}] of this._buffers.entries()) {\n      this._close(filePath, buffer);\n    }\n    invariant(this._buffers.size === 0);\n    this._resources.dispose();\n    this._fileEvents.complete();\n    this._directoryEvents.complete();\n  }\n\n  // getBuffer: returns whatever is the current version of the buffer.\n  getBuffer(filePath: NuclideUri): ?simpleTextBuffer$TextBuffer {\n    // TODO: change this to return a string, to ensure that no caller will ever mutate\n    // the buffer contents (and hence its changeCount). The only modifications allowed\n    // are those that come from the editor inside this.onFileEvent.\n    const fileInfo = this._buffers.get(filePath);\n    return fileInfo != null ? fileInfo.buffer : null;\n  }\n\n  // getBufferAtVersion(version): if the stream of onFileEvent gets up to this particular\n  // version, either now or in the future, then will return the buffer for that version.\n  // But if for whatever reason the stream of onFileEvent won't hit that precise version\n  // then returns null. See comments in _requests.waitForBufferAtVersion for\n  // the subtle scenarios where it might return null.\n  async getBufferAtVersion(\n    fileVersion: FileVersion,\n  ): Promise<?simpleTextBuffer$TextBuffer> {\n    // TODO: change this to return a string, like getBuffer() above.\n    if (!await this._requests.waitForBufferAtVersion(fileVersion)) {\n      return null;\n    }\n    const buffer = this.getBuffer(fileVersion.filePath);\n    return buffer != null && buffer.changeCount === fileVersion.version\n      ? buffer\n      : null;\n  }\n\n  // getBufferForFileEvent - this function may be called immediately when an edit or save\n  // event happens, before any awaits. At that time the buffer is guaranteed to be\n  // available. If called at any other time, the buffer may no longer be available,\n  // in which case it may throw.\n  getBufferForFileEvent(fileEvent: FileEvent): simpleTextBuffer$TextBuffer {\n    // TODO: change this to return a string, like getBuffer() above.\n    const fileVersion = fileEvent.fileVersion;\n    invariant(this._requests.isBufferAtVersion(fileVersion));\n    const buffer = this.getBuffer(fileVersion.filePath);\n    invariant(buffer != null && buffer.changeCount === fileVersion.version);\n    return buffer;\n  }\n\n  getOpenDirectories(): Set<NuclideUri> {\n    return this._directoryEvents.getValue();\n  }\n\n  // Returns directory which contains this path if any.\n  // Remote equivalent of atom.project.relativizePath()[1]\n  // TODO: Return the most nested open directory.\n  //       Note that Atom doesn't do this, though it should.\n  getContainingDirectory(filePath: NuclideUri): ?NuclideUri {\n    for (const dir of this.getOpenDirectories()) {\n      if (nuclideUri.contains(dir, filePath)) {\n        return dir;\n      }\n    }\n    return null;\n  }\n\n  getOpenFiles(): Iterator<NuclideUri> {\n    return this._buffers.keys();\n  }\n\n  observeFileEvents(): Observable<LocalFileEvent> {\n    return Observable.from(\n      Array.from(this._buffers.entries()).map(\n        ([filePath, {buffer, languageId}]) => {\n          invariant(buffer != null);\n          invariant(languageId != null);\n          return createOpenEvent(\n            this.createFileVersion(filePath, buffer.changeCount),\n            buffer.getText(),\n            languageId,\n          );\n        },\n      ),\n    ).concat(this._fileEvents);\n  }\n\n  observeDirectoryEvents(): Observable<Set<NuclideUri>> {\n    return this._directoryEvents;\n  }\n\n  createFileVersion(filePath: NuclideUri, version: number): FileVersion {\n    return {\n      notifier: this,\n      filePath,\n      version,\n    };\n  }\n}\n\nfunction createOpenEvent(\n  fileVersion: FileVersion,\n  contents: string,\n  languageId: string,\n): FileOpenEvent {\n  return {\n    kind: FileEventKind.OPEN,\n    fileVersion,\n    contents,\n    languageId,\n  };\n}\n\nfunction createCloseEvent(fileVersion: FileVersion): FileCloseEvent {\n  return {\n    kind: FileEventKind.CLOSE,\n    fileVersion,\n  };\n}\n\nfunction createSaveEvent(fileVersion: FileVersion): FileSaveEvent {\n  return {\n    kind: FileEventKind.SAVE,\n    fileVersion,\n  };\n}\n\nfunction createEditEvent(\n  fileVersion: FileVersion,\n  oldRange: atom$Range,\n  oldText: string,\n  newRange: atom$Range,\n  newText: string,\n): FileEditEvent {\n  return {\n    kind: FileEventKind.EDIT,\n    fileVersion,\n    oldRange,\n    oldText,\n    newRange,\n    newText,\n  };\n}\n"]}