{"version":3,"sources":["../../../../src/pkg/nuclide-language-service-rpc/lib/HostServicesAggregator.js"],"names":["host","logger","child","HostServicesAggregator","howChildShouldRelayBackToHost","childRegister","initialize","forkHostServices","constructor","_childRelays","Map","_counter","_isDisposed","relay","HostServicesRelay","set","parent","_parent","_logger","_selfRelay","get","consoleNotification","source","level","text","dialogNotification","applyTextEditsForMultipleFiles","changes","dialogRequest","buttonLabels","closeLabel","showProgress","title","options","showActionRequired","isDisposed","dispose","_disposables","values","_child","aggregator","id","_childIsDisposed","_aggregator","_id","add","next","empty","publish","refCount","takeUntil","Promise","resolve","no_op","setTitle","parentPromise","cancel","toPromise","progress","race","disposed","then","progress2","wrapper","title2","remove","delete"],"mappings":";;;;;;;;;;;;6CAwBO,WACLA,IADK,EAELC,MAFK,EAGkB;AACvB,UAAMC,QAAQ,IAAIC,sBAAJ,EAAd;AACA,UAAMC,gCAAgC,MAAMJ,KAAKK,aAAL,CAAmBH,KAAnB,CAA5C;AACAA,UAAMI,UAAN,CAAiBF,6BAAjB,EAAgDH,MAAhD;AACA,WAAOC,KAAP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD,G;;kBA3CqBK,gB;;;;;AARtB;;;;AACA;;AACA;;;;;;AAEA;AApBA;;;;;;;;;;;;AAqBG,IAAH;AACG,IAAH;;AA+CA,MAAMJ,sBAAN,CAA6B;;AAO3BK,gBAAc;AAAA,SALdC,YAKc,GALiC,IAAIC,GAAJ,EAKjC;AAAA,SAJdC,QAIc,GAJK,CAIL;AAAA,SAFdC,WAEc,GAFS,KAET;;AACZ;AACA;AACA;AACA;AACA,UAAMC,QAAQ,IAAIC,iBAAJ,CAAsB,IAAtB,EAA4B,CAA5B,EAA+B,IAA/B,CAAd;AACA,SAAKL,YAAL,CAAkBM,GAAlB,CAAsB,CAAtB,EAAyBF,KAAzB;AACD;;AAEDP,aAAWU,MAAX,EAAiCf,MAAjC,EAA8D;AAC5D,SAAKgB,OAAL,GAAeD,MAAf;AACA,SAAKE,OAAL,GAAejB,MAAf;AACD;;AAEDkB,eAAgC;AAC9B,UAAMN,QAAQ,KAAKJ,YAAL,CAAkBW,GAAlB,CAAsB,CAAtB,CAAd;AACA,0BAAUP,SAAS,IAAnB;AACA,WAAOA,KAAP;AACD;;AAEDQ,sBACEC,MADF,EAEEC,KAFF,EAGEC,IAHF,EAIQ;AACN,SAAKL,UAAL,GAAkBE,mBAAlB,CAAsCC,MAAtC,EAA8CC,KAA9C,EAAqDC,IAArD;AACD;;AAEDC,qBACEF,KADF,EAEEC,IAFF,EAG+B;AAC7B,WAAO,KAAKL,UAAL,GAAkBM,kBAAlB,CAAqCF,KAArC,EAA4CC,IAA5C,CAAP;AACD;;AAEDE,iCACEC,OADF,EAEoB;AAClB,WAAO,KAAKR,UAAL,GAAkBO,8BAAlB,CAAiDC,OAAjD,CAAP;AACD;;AAEDC,gBACEL,KADF,EAEEC,IAFF,EAGEK,YAHF,EAIEC,UAJF,EAKiC;AAC/B,WAAO,KAAKX,UAAL,GAAkBS,aAAlB,CACLL,KADK,EAELC,IAFK,EAGLK,YAHK,EAILC,UAJK,CAAP;AAMD;;AAEDC,eACEC,KADF,EAEEC,OAFF,EAGqB;AACnB,WAAO,KAAKd,UAAL,GAAkBY,YAAlB,CAA+BC,KAA/B,EAAsCC,OAAtC,CAAP;AACD;;AAEDC,qBACEF,KADF,EAEEC,OAFF,EAG+B;AAC7B,WAAO,KAAKd,UAAL,GAAkBe,kBAAlB,CAAqCF,KAArC,EAA4CC,OAA5C,CAAP;AACD;;AAEDE,eAAsB;AACpB,WAAO,KAAKvB,WAAZ;AACD;;AAED;AACAwB,YAAgB;AACd;AACA,QAAI,KAAKxB,WAAT,EAAsB;AACpB;AACD;;AAED;AACA;AACA,SAAKO,UAAL,GAAkBkB,YAAlB,CAA+BD,OAA/B;;AAEA;AACA;AACA;AACA;AAbc;AAAA;AAAA;;AAAA;AAcd,2BAAoB,KAAK3B,YAAL,CAAkB6B,MAAlB,EAApB,8HAAgD;AAAA,cAArCzB,KAAqC;;AAC9C,YAAIA,MAAM0B,MAAN,IAAgB,IAApB,EAA0B;AACxB1B,gBAAM0B,MAAN,CAAaH,OAAb;AACD;AACF;AAlBa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoBd,SAAKxB,WAAL,GAAmB,IAAnB;;AAEA;AACA,QAAI,KAAKK,OAAL,IAAgB,IAApB,EAA0B;AACxB;AACA;AACA;AACA,WAAKA,OAAL,CAAamB,OAAb;AACD;AACF;;AAEK/B,eAAN,CAAoBH,KAApB,EAAgE;AAAA;;AAAA;AAC9D;AACA;AACA;AACA,YAAKS,QAAL;AACA,YAAME,QAAQ,IAAIC,iBAAJ,QAA4B,MAAKH,QAAjC,EAA2CT,KAA3C,CAAd;AACA,UAAI,MAAKiC,UAAL,EAAJ,EAAuB;AACrBjC,cAAMkC,OAAN;AACD,OAFD,MAEO;AACL,cAAK3B,YAAL,CAAkBM,GAAlB,CAAsB,MAAKJ,QAA3B,EAAqCE,KAArC;AACD;AACD,aAAOA,KAAP;AAX8D;AAY/D;AA5H0B;;AA+H7B,MAAMC,iBAAN,CAAwB;AAKtB;AACA;AACA;AACA;AAIAN,cACEgC,UADF,EAEEC,EAFF,EAGEvC,KAHF,EAIE;AAAA,SAPFwC,gBAOE,GAPgC,mBAOhC;AAAA,SANFL,YAME,GANkC,mCAMlC;;AACA,SAAKM,WAAL,GAAmBH,UAAnB;AACA,SAAKI,GAAL,GAAWH,EAAX;AACA,SAAKF,MAAL,GAAcrC,KAAd;AACA,SAAKmC,YAAL,CAAkBQ,GAAlB,CAAsB,MAAM;AAC1B,WAAKH,gBAAL,CAAsBI,IAAtB;AACD,KAFD;AAGD;AApBD;;;AAsBAzB,sBACEC,MADF,EAEEC,KAFF,EAGEC,IAHF,EAIQ;AACN,QAAI,KAAKmB,WAAL,CAAiBR,UAAjB,EAAJ,EAAmC;AACjC;AACD;AACD,SAAKQ,WAAL,CAAiB1B,OAAjB,CAAyBI,mBAAzB,CAA6CC,MAA7C,EAAqDC,KAArD,EAA4DC,IAA5D;AACD;;AAEDC,qBACEF,KADF,EAEEC,IAFF,EAG+B;AAC7B,QAAI,KAAKmB,WAAL,CAAiBR,UAAjB,EAAJ,EAAmC;AACjC,aAAO,iBAAWY,KAAX,GAAmBC,OAAnB,EAAP;AACD;AACD,WAAO,KAAKL,WAAL,CAAiB1B,OAAjB,CACJQ,kBADI,CACeF,KADf,EACsBC,IADtB,EAEJyB,QAFI,GAGJC,SAHI,CAGM,KAAKR,gBAHX,EAIJM,OAJI,EAAP;AAKA;AACA;AACA;AACD;;AAEDpB,gBACEL,KADF,EAEEC,IAFF,EAGEK,YAHF,EAIEC,UAJF,EAKiC;AAC/B,QAAI,KAAKa,WAAL,CAAiBR,UAAjB,EAAJ,EAAmC;AACjC,aAAO,iBAAWY,KAAX,GAAmBC,OAAnB,EAAP;AACD;AACD,WAAO,KAAKL,WAAL,CAAiB1B,OAAjB,CACJW,aADI,CACUL,KADV,EACiBC,IADjB,EACuBK,YADvB,EACqCC,UADrC,EAEJmB,QAFI,GAGJC,SAHI,CAGM,KAAKR,gBAHX,EAIJM,OAJI,EAAP;AAKD;;AAEDtB,iCACEC,OADF,EAEoB;AAClB,QAAI,KAAKgB,WAAL,CAAiBR,UAAjB,EAAJ,EAAmC;AACjC,aAAOgB,QAAQC,OAAR,CAAgB,KAAhB,CAAP;AACD;AACD,WAAO,KAAKT,WAAL,CAAiB1B,OAAjB,CAAyBS,8BAAzB,CAAwDC,OAAxD,CAAP;AACD;;AAEKI,cAAN,CACEC,KADF,EAEEC,OAFF,EAGqB;AAAA;;AAAA;AACnB;AACA;AACA;AACA;AAGA,YAAMoB,QAAkB;AACtBC,kBAAU,qBAAK,CAAE,CADK;AAEtBlB,iBAAS,mBAAM,CAAE;AAFK,OAAxB;;AAKA;AACA,UAAI,OAAKO,WAAL,CAAiBR,UAAjB,EAAJ,EAAmC;AACjC,eAAOkB,KAAP;AACD;;AAED;AACA,YAAME,gBAAgB,OAAKZ,WAAL,CAAiB1B,OAAjB,CAAyBc,YAAzB,CAAsCC,KAAtC,EAA6CC,OAA7C,CAAtB;AACA,YAAMuB,SAAS,OAAKd,gBAAL,CAAsBe,SAAtB,EAAf;AACA,UAAIC,WAAsB,MAAMP,QAAQQ,IAAR,CAAa,CAACJ,aAAD,EAAgBC,MAAhB,CAAb,CAAhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UACEE,YAAY,IAAZ,IACA,OAAKf,WAAL,CAAiBR,UAAjB,EADA,IAEA,OAAKE,YAAL,CAAkBuB,QAHpB,EAIE;AACAL,sBAAcM,IAAd,CAAmB;AAAA,iBAAaC,UAAU1B,OAAV,EAAb;AAAA,SAAnB;AACA,eAAOiB,KAAP;AACD;;AAED;AACA;AACA;AACA,YAAMU,UAAoB;AACxBT,kBAAU,0BAAU;AAClB,cAAII,YAAY,IAAhB,EAAsB;AACpBA,qBAASJ,QAAT,CAAkBU,MAAlB;AACD;AACF,SALuB;AAMxB5B,iBAAS,mBAAM;AACb,iBAAKC,YAAL,CAAkB4B,MAAlB,CAAyBF,OAAzB;AACA,cAAIL,YAAY,IAAhB,EAAsB;AACpBA,qBAAStB,OAAT;AACAsB,uBAAW,IAAX;AACD;AACF;AAZuB,OAA1B;AAcA,aAAKrB,YAAL,CAAkBQ,GAAlB,CAAsBkB,OAAtB;AACA,aAAOA,OAAP;AAvDmB;AAwDpB;;AAED7B,qBACEF,KADF,EAEEC,OAFF,EAG+B;AAC7B,QAAI,KAAKU,WAAL,CAAiBR,UAAjB,EAAJ,EAAmC;AACjC,aAAO,iBAAWY,KAAX,GAAmBC,OAAnB,EAAP;AACD;AACD,WAAO,KAAKL,WAAL,CAAiB1B,OAAjB,CACJiB,kBADI,CACeF,KADf,EACsBC,OADtB,EAEJgB,QAFI,GAGJC,SAHI,CAGM,KAAKR,gBAHX,EAIJM,OAJI,EAAP;AAKD;;AAEDZ,YAAgB;AACd,QAAI,CAAC,KAAKC,YAAL,CAAkBuB,QAAvB,EAAiC;AAC/B;AACA;AACA;AACA,WAAKvB,YAAL,CAAkBD,OAAlB;AACA,WAAKO,WAAL,CAAiBlC,YAAjB,CAA8ByD,MAA9B,CAAqC,KAAKtB,GAA1C;AACD;AACF;;AAEDvC,gBAAcH,KAAd,EAA0D;AACxD,0BAAU,KAAV,EAAiB,oDAAjB;AACD;AArKqB","file":"HostServicesAggregator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {ShowNotificationLevel, Progress, HostServices} from './rpc-types';\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {TextEdit} from 'nuclide-commons-atom/text-edit';\n\nimport invariant from 'assert';\nimport {Subject, ConnectableObservable, Observable} from 'rxjs';\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\n\n// This is how we declare in Flow that a type fulfills an interface.\n(((null: any): HostServicesAggregator): HostServices);\n(((null: any): HostServicesRelay): HostServices);\n\nexport async function forkHostServices(\n  host: HostServices,\n  logger: log4js$Logger,\n): Promise<HostServices> {\n  const child = new HostServicesAggregator();\n  const howChildShouldRelayBackToHost = await host.childRegister(child);\n  child.initialize(howChildShouldRelayBackToHost, logger);\n  return child;\n\n  // Here's an example tree of forked aggregators, with a vertical line to show\n  // client-side objects on the left and server-side objects on the right.\n  //\n  // root            |\n  //   <-> relayR0   |\n  //   <-> relayR1 <-|-> aggregator\n  //                 |    <-> relayA0\n  //                 |    <-> relayA1 <-> child1\n  //                 |    <-> relayA2 <-> child2\n  //\n  // If you call child1.consoleNotification(), it forwards to relayA1, which\n  // forwards it on to relayR1. The buck stops at the root which is responsible\n  // for displaying it.\n  //\n  // We also offer the same HostServices API on aggregator itself.\n  // If you call aggregator.consoleNotification() it just dispatches to relayA0,\n  // which behaves identically to relayA1 above. (We use relayA0 here, rather\n  // than handling the call inside aggregator itself, to avoid code duplication)\n  //\n  // If you dispose child1, it relays news of its disposal via relayA1, which\n  // removes it from aggregator's list of children.\n  //\n  // If you dispose aggregator, it disposes all of its remaining children, and\n  // relays news of its disposal via relayR1, which removes it from root's\n  // list of children.\n  //\n  // The call to 'root.childRegister(aggregator)' is what creates relayR1.\n  // This call might be across nuclide-rpc, which is why childRegister has to\n  // return a promise.\n  //\n  // Why do we use relays? so that each child can relay messages to its parent\n  // aggregator, and so the parent aggregator can know which child that message\n  // was relayed from, and so we can do all this without lots of duplicate\n  // methods in the HostServices interface.\n}\n\nclass HostServicesAggregator {\n  _parent: HostServices;\n  _childRelays: Map<number, HostServicesRelay> = new Map();\n  _counter: number = 0;\n  _logger: log4js$Logger;\n  _isDisposed: boolean = false;\n\n  constructor() {\n    // HostServiceAggregator objects are only ever constructed from forkHostServices:\n    // 1. it calls the constructor (here)\n    // 2. it calls parent.childRegister(child)\n    // 3. it calls child.initialize(parent)\n    const relay = new HostServicesRelay(this, 0, null);\n    this._childRelays.set(0, relay);\n  }\n\n  initialize(parent: HostServices, logger: log4js$Logger): void {\n    this._parent = parent;\n    this._logger = logger;\n  }\n\n  _selfRelay(): HostServicesRelay {\n    const relay = this._childRelays.get(0);\n    invariant(relay != null);\n    return relay;\n  }\n\n  consoleNotification(\n    source: string,\n    level: ShowNotificationLevel,\n    text: string,\n  ): void {\n    this._selfRelay().consoleNotification(source, level, text);\n  }\n\n  dialogNotification(\n    level: ShowNotificationLevel,\n    text: string,\n  ): ConnectableObservable<void> {\n    return this._selfRelay().dialogNotification(level, text);\n  }\n\n  applyTextEditsForMultipleFiles(\n    changes: Map<NuclideUri, Array<TextEdit>>,\n  ): Promise<boolean> {\n    return this._selfRelay().applyTextEditsForMultipleFiles(changes);\n  }\n\n  dialogRequest(\n    level: ShowNotificationLevel,\n    text: string,\n    buttonLabels: Array<string>,\n    closeLabel: string,\n  ): ConnectableObservable<string> {\n    return this._selfRelay().dialogRequest(\n      level,\n      text,\n      buttonLabels,\n      closeLabel,\n    );\n  }\n\n  showProgress(\n    title: string,\n    options?: {|debounce?: boolean|},\n  ): Promise<Progress> {\n    return this._selfRelay().showProgress(title, options);\n  }\n\n  showActionRequired(\n    title: string,\n    options?: {|clickable?: boolean|},\n  ): ConnectableObservable<void> {\n    return this._selfRelay().showActionRequired(title, options);\n  }\n\n  isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  // Call 'dispose' to dispose of the aggregate and all its children\n  dispose(): void {\n    // Guard against double-disposal (see below).\n    if (this._isDisposed) {\n      return;\n    }\n\n    // We'll explicitly dispose of everything that our own self relay keeps\n    // track of (e.g. outstanding busy signals, notifications, ...)\n    this._selfRelay()._disposables.dispose();\n\n    // Next, for every child aggregate, tell it to dispose itself too.\n    // The relay.child will notify the relay that it has been disposed, and\n    // that's when the relay will do any further cleanup.\n    // Note: _selfRelay is the only member of _childRelays that lacks _child.\n    for (const relay of this._childRelays.values()) {\n      if (relay._child != null) {\n        relay._child.dispose();\n      }\n    }\n\n    this._isDisposed = true;\n\n    // Finally, relay to our parent that we've been disposed.\n    if (this._parent != null) {\n      // If our parent were already disposed at the time forkHostServices was\n      // called, then its childRegister method would have disposed us even before\n      // our _parent was hooked up.\n      this._parent.dispose();\n    }\n  }\n\n  async childRegister(child: HostServices): Promise<HostServices> {\n    // The code which has a HostServices object doesn't necessarily know that\n    // its parent might have been disposed. And if it tries to fork, that\n    // should still succeed and produce a disposed child HostServices object.\n    this._counter++;\n    const relay = new HostServicesRelay(this, this._counter, child);\n    if (this.isDisposed()) {\n      child.dispose();\n    } else {\n      this._childRelays.set(this._counter, relay);\n    }\n    return relay;\n  }\n}\n\nclass HostServicesRelay {\n  _aggregator: HostServicesAggregator;\n  _id: number;\n  //\n  _child: ?HostServices;\n  // _childIsDisposed is consumed by using observable.takeUntil(_childIsDisposed),\n  // which unsubscribes from 'obs' as soon as _childIsDisposed.next() gets\n  // fired. It is signaled by calling _disposables.dispose(), which fires\n  // the _childIsDisposed.next().\n  _childIsDisposed: Subject<void> = new Subject();\n  _disposables: UniversalDisposable = new UniversalDisposable();\n\n  constructor(\n    aggregator: HostServicesAggregator,\n    id: number,\n    child: ?HostServices,\n  ) {\n    this._aggregator = aggregator;\n    this._id = id;\n    this._child = child;\n    this._disposables.add(() => {\n      this._childIsDisposed.next();\n    });\n  }\n\n  consoleNotification(\n    source: string,\n    level: ShowNotificationLevel,\n    text: string,\n  ): void {\n    if (this._aggregator.isDisposed()) {\n      return;\n    }\n    this._aggregator._parent.consoleNotification(source, level, text);\n  }\n\n  dialogNotification(\n    level: ShowNotificationLevel,\n    text: string,\n  ): ConnectableObservable<void> {\n    if (this._aggregator.isDisposed()) {\n      return Observable.empty().publish();\n    }\n    return this._aggregator._parent\n      .dialogNotification(level, text)\n      .refCount()\n      .takeUntil(this._childIsDisposed)\n      .publish();\n    // If the host is disposed, then the ConnectedObservable we return will\n    // complete without ever having emitted a value. If you .toPromise on it\n    // your promise will complete successfully with value 'undefined'.\n  }\n\n  dialogRequest(\n    level: ShowNotificationLevel,\n    text: string,\n    buttonLabels: Array<string>,\n    closeLabel: string,\n  ): ConnectableObservable<string> {\n    if (this._aggregator.isDisposed()) {\n      return Observable.empty().publish();\n    }\n    return this._aggregator._parent\n      .dialogRequest(level, text, buttonLabels, closeLabel)\n      .refCount()\n      .takeUntil(this._childIsDisposed)\n      .publish();\n  }\n\n  applyTextEditsForMultipleFiles(\n    changes: Map<NuclideUri, Array<TextEdit>>,\n  ): Promise<boolean> {\n    if (this._aggregator.isDisposed()) {\n      return Promise.resolve(false);\n    }\n    return this._aggregator._parent.applyTextEditsForMultipleFiles(changes);\n  }\n\n  async showProgress(\n    title: string,\n    options?: {|debounce?: boolean|},\n  ): Promise<Progress> {\n    // TODO: this whole function would work better with CancellationToken,\n    // particularly in the case where a HostAggregator is disposed after the\n    // request has already been sent out to its parent. In the absence of\n    // CancellationToken, we can't cancel the parent, and instead have to\n    // wait until it *displays* progress before immediately disposing it.\n\n    const no_op: Progress = {\n      setTitle: _ => {},\n      dispose: () => {},\n    };\n\n    // If we're already disposed, then return a no-op wrapper.\n    if (this._aggregator.isDisposed()) {\n      return no_op;\n    }\n\n    // Otherwise, we are going to make a request to our parent.\n    const parentPromise = this._aggregator._parent.showProgress(title, options);\n    const cancel = this._childIsDisposed.toPromise();\n    let progress: ?Progress = await Promise.race([parentPromise, cancel]);\n\n    // Should a cancellation come while we're waiting for our parent,\n    // then we'll immediately return a no-op wrapper and ensure that\n    // the one from our parent will eventually be disposed.\n    // The \"or\" check below is in case parentProgress returned something\n    // but also either the parent aggregator or the child aggregator\n    // were disposed.\n    if (\n      progress == null ||\n      this._aggregator.isDisposed() ||\n      this._disposables.disposed\n    ) {\n      parentPromise.then(progress2 => progress2.dispose());\n      return no_op;\n    }\n\n    // Here our parent has already displayed 'winner'. It will be disposed\n    // either when we ourselves get disposed, or when our caller disposes\n    // of the wrapper we return them, whichever happens first.\n    const wrapper: Progress = {\n      setTitle: title2 => {\n        if (progress != null) {\n          progress.setTitle(title2);\n        }\n      },\n      dispose: () => {\n        this._disposables.remove(wrapper);\n        if (progress != null) {\n          progress.dispose();\n          progress = null;\n        }\n      },\n    };\n    this._disposables.add(wrapper);\n    return wrapper;\n  }\n\n  showActionRequired(\n    title: string,\n    options?: {|clickable?: boolean|},\n  ): ConnectableObservable<void> {\n    if (this._aggregator.isDisposed()) {\n      return Observable.empty().publish();\n    }\n    return this._aggregator._parent\n      .showActionRequired(title, options)\n      .refCount()\n      .takeUntil(this._childIsDisposed)\n      .publish();\n  }\n\n  dispose(): void {\n    if (!this._disposables.disposed) {\n      // Remember, this is a notification relayed from one of the children that\n      // it has just finished its \"dispose\" method. That's what a relay is.\n      // It is *NOT* a means to dispose of this relay\n      this._disposables.dispose();\n      this._aggregator._childRelays.delete(this._id);\n    }\n  }\n\n  childRegister(child: HostServices): Promise<HostServices> {\n    invariant(false, 'relay should never be asked to relay childRegister');\n  }\n}\n"]}