{"version":3,"sources":["../../../../src/pkg/nuclide-language-service-rpc/lib/ServerLanguageService.js"],"names":["ensureInvalidations","ServerLanguageService","constructor","fileNotifier","service","_fileCache","_service","getSingleFileLanguageService","getDiagnostics","fileVersion","filePath","buffer","observeDiagnostics","publish","getAutocompleteSuggestions","position","request","isIncomplete","items","activatedManually","prefix","getDefinition","findReferences","fromPromise","concatMap","of","getCoverage","getAdditionalLogFiles","getCodeActions","range","diagnostics","getOutline","typeHint","highlight","formatSource","options","formatEntireFile","formatAtPosition","triggerCharacter","getEvaluationExpression","supportsSymbolSearch","directories","Promise","resolve","symbolSearch","query","getProjectRoot","fileUri","isFileInProject","getExpandedSelectionRange","currentSelection","getCollapsedSelectionRange","originalCursorPosition","dispose","logger","filesWithErrors","Set","trackedDiagnostics","do","diagnosticMap","messages","length","debug","delete","add","fileInvalidations","defer","Map","Array","from","map","file","concat"],"mappings":"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","file":"ServerLanguageService.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {AdditionalLogFile} from '../../nuclide-logging/lib/rpc-types';\nimport type {FileVersion} from '../../nuclide-open-files-rpc/lib/rpc-types';\nimport type {TextEdit} from 'nuclide-commons-atom/text-edit';\nimport type {TypeHint} from '../../nuclide-type-hint/lib/rpc-types';\nimport type {CoverageResult} from '../../nuclide-type-coverage/lib/rpc-types';\nimport type {\n  DefinitionQueryResult,\n  FindReferencesReturn,\n  Outline,\n  CodeAction,\n} from 'atom-ide-ui';\nimport type {\n  AutocompleteRequest,\n  AutocompleteResult,\n  FileDiagnosticMap,\n  FileDiagnosticMessage,\n  FormatOptions,\n  LanguageService,\n  SymbolResult,\n} from '../../nuclide-language-service/lib/LanguageService';\nimport type {FileNotifier} from '../../nuclide-open-files-rpc/lib/rpc-types';\nimport type {ConnectableObservable} from 'rxjs';\nimport type {NuclideEvaluationExpression} from 'nuclide-debugger-common';\n\nimport invariant from 'assert';\nimport {getBufferAtVersion} from '../../nuclide-open-files-rpc';\nimport {FileCache} from '../../nuclide-open-files-rpc';\nimport {Observable} from 'rxjs';\n\n// This is a version of the LanguageService interface which operates on a\n// single modified file at a time. This provides a simplified interface\n// for LanguageService implementors, at the cost of providing language analysis\n// which can not reflect multiple edited files.\nexport type SingleFileLanguageService = {\n  getDiagnostics(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n  ): Promise<?FileDiagnosticMap>,\n\n  observeDiagnostics(): Observable<FileDiagnosticMap>,\n\n  getAutocompleteSuggestions(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n    activatedManually: boolean,\n    prefix: string,\n  ): Promise<?AutocompleteResult>,\n\n  getDefinition(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?DefinitionQueryResult>,\n\n  findReferences(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Observable<?FindReferencesReturn>,\n\n  getCoverage(filePath: NuclideUri): Promise<?CoverageResult>,\n\n  getOutline(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n  ): Promise<?Outline>,\n\n  getCodeActions(\n    filePath: NuclideUri,\n    range: atom$Range,\n    diagnostics: Array<FileDiagnosticMessage>,\n  ): Promise<Array<CodeAction>>,\n\n  typeHint(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?TypeHint>,\n\n  highlight(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?Array<atom$Range>>,\n\n  formatSource(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    range: atom$Range,\n    options: FormatOptions,\n  ): Promise<?Array<TextEdit>>,\n\n  formatEntireFile(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    range: atom$Range,\n    options: FormatOptions,\n  ): Promise<?{\n    newCursor?: number,\n    formatted: string,\n  }>,\n\n  formatAtPosition(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n    triggerCharacter: string,\n    options: FormatOptions,\n  ): Promise<?Array<TextEdit>>,\n\n  getEvaluationExpression(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?NuclideEvaluationExpression>,\n\n  getProjectRoot(fileUri: NuclideUri): Promise<?NuclideUri>,\n\n  isFileInProject(fileUri: NuclideUri): Promise<boolean>,\n\n  getExpandedSelectionRange(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    currentSelection: atom$Range,\n  ): Promise<?atom$Range>,\n\n  getCollapsedSelectionRange(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    currentSelection: atom$Range,\n    originalCursorPosition: atom$Point,\n  ): Promise<?atom$Range>,\n\n  dispose(): void,\n};\n\nexport class ServerLanguageService<\n  T: SingleFileLanguageService = SingleFileLanguageService,\n> {\n  _fileCache: FileCache;\n  _service: T;\n\n  constructor(fileNotifier: FileNotifier, service: T) {\n    invariant(fileNotifier instanceof FileCache);\n    this._fileCache = fileNotifier;\n    this._service = service;\n  }\n\n  getSingleFileLanguageService(): T {\n    return this._service;\n  }\n\n  async getDiagnostics(fileVersion: FileVersion): Promise<?FileDiagnosticMap> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.getDiagnostics(filePath, buffer);\n  }\n\n  observeDiagnostics(): ConnectableObservable<FileDiagnosticMap> {\n    return this._service.observeDiagnostics().publish();\n  }\n\n  async getAutocompleteSuggestions(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    request: AutocompleteRequest,\n  ): Promise<?AutocompleteResult> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      // TODO: this should return null so the empty list doesn't get cached\n      return {isIncomplete: false, items: []};\n    }\n    return this._service.getAutocompleteSuggestions(\n      filePath,\n      buffer,\n      position,\n      request.activatedManually,\n      request.prefix,\n    );\n  }\n\n  async getDefinition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?DefinitionQueryResult> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.getDefinition(filePath, buffer, position);\n  }\n\n  findReferences(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): ConnectableObservable<?FindReferencesReturn> {\n    const filePath = fileVersion.filePath;\n    return Observable.fromPromise(getBufferAtVersion(fileVersion))\n      .concatMap(buffer => {\n        if (buffer == null) {\n          return Observable.of(null);\n        }\n        return this._service.findReferences(filePath, buffer, position);\n      })\n      .publish();\n  }\n\n  getCoverage(filePath: NuclideUri): Promise<?CoverageResult> {\n    return this._service.getCoverage(filePath);\n  }\n\n  async getAdditionalLogFiles(): Promise<Array<AdditionalLogFile>> {\n    // TODO (if it's ever needed): push this request to the this._service\n    return [];\n  }\n\n  async getCodeActions(\n    fileVersion: FileVersion,\n    range: atom$Range,\n    diagnostics: Array<FileDiagnosticMessage>,\n  ): Promise<Array<CodeAction>> {\n    const {filePath} = fileVersion;\n    return this._service.getCodeActions(filePath, range, diagnostics);\n  }\n\n  async getOutline(fileVersion: FileVersion): Promise<?Outline> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.getOutline(filePath, buffer);\n  }\n\n  async typeHint(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?TypeHint> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.typeHint(filePath, buffer, position);\n  }\n\n  async highlight(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?Array<atom$Range>> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return [];\n    }\n    return this._service.highlight(filePath, buffer, position);\n  }\n\n  async formatSource(\n    fileVersion: FileVersion,\n    range: atom$Range,\n    options: FormatOptions,\n  ): Promise<?Array<TextEdit>> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.formatSource(filePath, buffer, range, options);\n  }\n\n  async formatEntireFile(\n    fileVersion: FileVersion,\n    range: atom$Range,\n    options: FormatOptions,\n  ): Promise<?{\n    newCursor?: number,\n    formatted: string,\n  }> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.formatEntireFile(filePath, buffer, range, options);\n  }\n\n  async formatAtPosition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    triggerCharacter: string,\n    options: FormatOptions,\n  ): Promise<?Array<TextEdit>> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.formatAtPosition(\n      filePath,\n      buffer,\n      position,\n      triggerCharacter,\n      options,\n    );\n  }\n\n  async getEvaluationExpression(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?NuclideEvaluationExpression> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n    return this._service.getEvaluationExpression(filePath, buffer, position);\n  }\n\n  supportsSymbolSearch(directories: Array<NuclideUri>): Promise<boolean> {\n    return Promise.resolve(false);\n    // A single-file language service by definition cannot offer\n    // \"project-wide symbol search\". If you want your language to offer\n    // symbols, you'll have to implement LanguageService directly.\n  }\n\n  symbolSearch(\n    query: string,\n    directories: Array<NuclideUri>,\n  ): Promise<?Array<SymbolResult>> {\n    return Promise.resolve(null);\n  }\n\n  getProjectRoot(fileUri: NuclideUri): Promise<?NuclideUri> {\n    return this._service.getProjectRoot(fileUri);\n  }\n\n  async isFileInProject(fileUri: NuclideUri): Promise<boolean> {\n    return this._service.isFileInProject(fileUri);\n  }\n\n  async getExpandedSelectionRange(\n    fileVersion: FileVersion,\n    currentSelection: atom$Range,\n  ): Promise<?atom$Range> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n\n    return this._service.getExpandedSelectionRange(\n      filePath,\n      buffer,\n      currentSelection,\n    );\n  }\n\n  async getCollapsedSelectionRange(\n    fileVersion: FileVersion,\n    currentSelection: atom$Range,\n    originalCursorPosition: atom$Point,\n  ): Promise<?atom$Range> {\n    const filePath = fileVersion.filePath;\n    const buffer = await getBufferAtVersion(fileVersion);\n    if (buffer == null) {\n      return null;\n    }\n\n    return this._service.getCollapsedSelectionRange(\n      filePath,\n      buffer,\n      currentSelection,\n      originalCursorPosition,\n    );\n  }\n\n  dispose(): void {\n    this._service.dispose();\n  }\n}\n\n// Assert that ServerLanguageService satisifes the LanguageService interface:\n(((null: any): ServerLanguageService<>): LanguageService);\n\nexport function ensureInvalidations(\n  logger: log4js$Logger,\n  diagnostics: Observable<FileDiagnosticMap>,\n): Observable<FileDiagnosticMap> {\n  const filesWithErrors = new Set();\n  const trackedDiagnostics: Observable<FileDiagnosticMap> = diagnostics.do(\n    (diagnosticMap: FileDiagnosticMap) => {\n      for (const [filePath, messages] of diagnosticMap) {\n        if (messages.length === 0) {\n          logger.debug(`Removing ${filePath} from files with errors`);\n          filesWithErrors.delete(filePath);\n        } else {\n          logger.debug(`Adding ${filePath} to files with errors`);\n          filesWithErrors.add(filePath);\n        }\n      }\n    },\n  );\n\n  const fileInvalidations: Observable<FileDiagnosticMap> = Observable.defer(\n    () => {\n      logger.debug('Clearing errors after stream closed');\n      return Observable.of(\n        new Map(\n          Array.from(filesWithErrors).map(file => {\n            logger.debug(`Clearing errors for ${file} after connection closed`);\n            return [file, []];\n          }),\n        ),\n      );\n    },\n  );\n\n  return trackedDiagnostics.concat(fileInvalidations);\n}\n"]}