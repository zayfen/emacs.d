'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerLanguageService = undefined;

var _asyncToGenerator = require('async-to-generator');

var _asyncToGenerator2 = _interopRequireDefault(_asyncToGenerator);

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @format
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.ensureInvalidations = ensureInvalidations;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _nuclideOpenFilesRpc = require('../../nuclide-open-files-rpc');

var _rxjs = require('rxjs');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This is a version of the LanguageService interface which operates on a
// single modified file at a time. This provides a simplified interface
// for LanguageService implementors, at the cost of providing language analysis
// which can not reflect multiple edited files.
class ServerLanguageService {

  constructor(fileNotifier, service) {
    (0, _assert2.default)(fileNotifier instanceof _nuclideOpenFilesRpc.FileCache);
    this._fileCache = fileNotifier;
    this._service = service;
  }

  getSingleFileLanguageService() {
    return this._service;
  }

  getDiagnostics(fileVersion) {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return null;
      }
      return _this._service.getDiagnostics(filePath, buffer);
    })();
  }

  observeDiagnostics() {
    return this._service.observeDiagnostics().publish();
  }

  getAutocompleteSuggestions(fileVersion, position, request) {
    var _this2 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        // TODO: this should return null so the empty list doesn't get cached
        return { isIncomplete: false, items: [] };
      }
      return _this2._service.getAutocompleteSuggestions(filePath, buffer, position, request.activatedManually, request.prefix);
    })();
  }

  getDefinition(fileVersion, position) {
    var _this3 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return null;
      }
      return _this3._service.getDefinition(filePath, buffer, position);
    })();
  }

  findReferences(fileVersion, position) {
    const filePath = fileVersion.filePath;
    return _rxjs.Observable.fromPromise((0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion)).concatMap(buffer => {
      if (buffer == null) {
        return _rxjs.Observable.of(null);
      }
      return this._service.findReferences(filePath, buffer, position);
    }).publish();
  }

  getCoverage(filePath) {
    return this._service.getCoverage(filePath);
  }

  getAdditionalLogFiles() {
    return (0, _asyncToGenerator2.default)(function* () {
      // TODO (if it's ever needed): push this request to the this._service
      return [];
    })();
  }

  getCodeActions(fileVersion, range, diagnostics) {
    var _this4 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;

      return _this4._service.getCodeActions(filePath, range, diagnostics);
    })();
  }

  getOutline(fileVersion) {
    var _this5 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return null;
      }
      return _this5._service.getOutline(filePath, buffer);
    })();
  }

  typeHint(fileVersion, position) {
    var _this6 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return null;
      }
      return _this6._service.typeHint(filePath, buffer, position);
    })();
  }

  highlight(fileVersion, position) {
    var _this7 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return [];
      }
      return _this7._service.highlight(filePath, buffer, position);
    })();
  }

  formatSource(fileVersion, range, options) {
    var _this8 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return null;
      }
      return _this8._service.formatSource(filePath, buffer, range, options);
    })();
  }

  formatEntireFile(fileVersion, range, options) {
    var _this9 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return null;
      }
      return _this9._service.formatEntireFile(filePath, buffer, range, options);
    })();
  }

  formatAtPosition(fileVersion, position, triggerCharacter, options) {
    var _this10 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return null;
      }
      return _this10._service.formatAtPosition(filePath, buffer, position, triggerCharacter, options);
    })();
  }

  getEvaluationExpression(fileVersion, position) {
    var _this11 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return null;
      }
      return _this11._service.getEvaluationExpression(filePath, buffer, position);
    })();
  }

  supportsSymbolSearch(directories) {
    return Promise.resolve(false);
    // A single-file language service by definition cannot offer
    // "project-wide symbol search". If you want your language to offer
    // symbols, you'll have to implement LanguageService directly.
  }

  symbolSearch(query, directories) {
    return Promise.resolve(null);
  }

  getProjectRoot(fileUri) {
    return this._service.getProjectRoot(fileUri);
  }

  isFileInProject(fileUri) {
    var _this12 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      return _this12._service.isFileInProject(fileUri);
    })();
  }

  getExpandedSelectionRange(fileVersion, currentSelection) {
    var _this13 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return null;
      }

      return _this13._service.getExpandedSelectionRange(filePath, buffer, currentSelection);
    })();
  }

  getCollapsedSelectionRange(fileVersion, currentSelection, originalCursorPosition) {
    var _this14 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const filePath = fileVersion.filePath;
      const buffer = yield (0, _nuclideOpenFilesRpc.getBufferAtVersion)(fileVersion);
      if (buffer == null) {
        return null;
      }

      return _this14._service.getCollapsedSelectionRange(filePath, buffer, currentSelection, originalCursorPosition);
    })();
  }

  dispose() {
    this._service.dispose();
  }
}

exports.ServerLanguageService = ServerLanguageService; // Assert that ServerLanguageService satisifes the LanguageService interface:

null;

function ensureInvalidations(logger, diagnostics) {
  const filesWithErrors = new Set();
  const trackedDiagnostics = diagnostics.do(diagnosticMap => {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = diagnosticMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const _ref = _step.value;

        var _ref2 = _slicedToArray(_ref, 2);

        const filePath = _ref2[0];
        const messages = _ref2[1];

        if (messages.length === 0) {
          logger.debug(`Removing ${filePath} from files with errors`);
          filesWithErrors.delete(filePath);
        } else {
          logger.debug(`Adding ${filePath} to files with errors`);
          filesWithErrors.add(filePath);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  const fileInvalidations = _rxjs.Observable.defer(() => {
    logger.debug('Clearing errors after stream closed');
    return _rxjs.Observable.of(new Map(Array.from(filesWithErrors).map(file => {
      logger.debug(`Clearing errors for ${file} after connection closed`);
      return [file, []];
    })));
  });

  return trackedDiagnostics.concat(fileInvalidations);
}
//# sourceMappingURL=ServerLanguageService.js.map