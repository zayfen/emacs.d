{"version":3,"sources":["../../../../src/pkg/nuclide-language-service/lib/LanguageService.js"],"names":[],"mappings":";;AA+DA;AACA;AACA,CAAG,EAAH;;AA7BA;AApCA;;;;;;;;;;;;AA6FA;;;AAeA;AACG,IAAH","file":"LanguageService.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {DeadlineRequest} from 'nuclide-commons/promise';\nimport type {AdditionalLogFile} from '../../nuclide-logging/lib/rpc-types';\nimport type {FileVersion} from '../../nuclide-open-files-rpc/lib/rpc-types';\nimport type {TextEdit} from 'nuclide-commons-atom/text-edit';\nimport type {TypeHint} from '../../nuclide-type-hint/lib/rpc-types';\nimport type {CoverageResult} from '../../nuclide-type-coverage/lib/rpc-types';\nimport type {\n  DiagnosticFix,\n  DiagnosticMessage,\n  DiagnosticMessageKind,\n  DiagnosticMessageType,\n  DefinitionQueryResult,\n  DiagnosticTrace,\n  FindReferencesReturn,\n  Outline,\n  CodeAction,\n} from 'atom-ide-ui';\nimport type {ConnectableObservable} from 'rxjs';\nimport type {NuclideEvaluationExpression} from 'nuclide-debugger-common';\nimport type {SymbolResult} from '../../nuclide-quick-open/lib/types';\n\nexport type {SymbolResult} from '../../nuclide-quick-open/lib/types';\n\n// Subtype of atom$AutocompleteSuggestion.\nexport type Completion = {\n  // These fields are part of atom$AutocompleteSuggestion:\n  text?: string,\n  snippet?: string,\n  displayText?: string,\n  replacementPrefix?: string,\n  type?: ?string,\n  leftLabel?: ?string,\n  leftLabelHTML?: ?string,\n  rightLabel?: ?string,\n  rightLabelHTML?: ?string,\n  className?: ?string,\n  iconHTML?: ?string,\n  description?: ?string,\n  descriptionMoreURL?: ?string,\n  // These fields are extra:\n  filterText?: string, // used by updateAutocompleteResults\n  sortText?: string, // used by updateAutocompleteResults\n  extraData?: mixed, // used by whichever packages want to use it\n  // If textEdits are provided, snippet + text + replacementPrefix are **ignored** in favor of\n  // simply applying the given edits.\n  // The edits must not overlap and should contain the position of the completion request.\n  // Note: this is implemented in AutocompletionProvider and is not part of Atom's API.\n  textEdits?: Array<TextEdit>,\n};\n\n// This assertion ensures that Completion is a subtype of atom$AutocompleteSuggestion. If you are\n// getting errors here, you have probably just updated one without updating the other.\n((({}: any): Completion): atom$AutocompleteSuggestion);\n\nexport type AutocompleteResult = {\n  isIncomplete: boolean,\n  items: Array<Completion>,\n};\n\nexport type FormatOptions = {\n  // Size of a tab in spaces.\n  tabSize: number,\n  // Prefer spaces over tabs.\n  insertSpaces: boolean,\n};\n\nexport type AutocompleteRequest = {|\n  // The request might have been triggered manually (by the user pressing\n  // ctrl+space) or automatically (by the user typing into the buffer).\n  activatedManually: boolean,\n  // If it was an automatic trigger, this is the character to the left of the\n  // caret (i.e. what the user most likely just typed). If manual, it is null.\n  triggerCharacter: ?string,\n  // Prefix is that part of whatever word the caret's on that's to the left of\n  // the caret. This prefix is calculated heuristically by the caller via a\n  // language-appropriate regex. The results of autocomplete have the option to\n  // override this.\n  prefix: string,\n|};\n\n// A (RPC-able) subset of DiagnosticMessage.\nexport type FileDiagnosticMessage = {|\n  kind?: DiagnosticMessageKind,\n  providerName: string,\n  type: DiagnosticMessageType,\n  filePath: NuclideUri,\n  text?: string,\n  html?: string,\n  range?: atom$Range,\n  trace?: Array<DiagnosticTrace>,\n  fix?: DiagnosticFix,\n  actions?: void, // Help Flow believe this is a subtype.\n  stale?: boolean,\n|};\n\n// Ensure that this is actually a subset.\n(((null: any): FileDiagnosticMessage): DiagnosticMessage);\n\nexport type FileDiagnosticMap = Map<NuclideUri, Array<FileDiagnosticMessage>>;\n\nexport interface LanguageService {\n  getDiagnostics(fileVersion: FileVersion): Promise<?FileDiagnosticMap>;\n\n  observeDiagnostics(): ConnectableObservable<FileDiagnosticMap>;\n\n  getAutocompleteSuggestions(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    request: AutocompleteRequest,\n  ): Promise<?AutocompleteResult>;\n\n  getDefinition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?DefinitionQueryResult>;\n\n  findReferences(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): ConnectableObservable<?FindReferencesReturn>;\n\n  getCoverage(filePath: NuclideUri): Promise<?CoverageResult>;\n\n  getOutline(fileVersion: FileVersion): Promise<?Outline>;\n\n  /**\n   * Requests CodeActions from a language service. This function can be called either\n   * whenever the cursor position changes (in which case the range should be from\n   * the beginning of the current word to the cursor's position) or whenever a user interacts\n   * with a Diagnostic (in which case the range should be the range of that diagnostic)\n   *\n   * If no CodeActions are available, an empty array should be returned.\n   */\n  getCodeActions(\n    fileVersion: FileVersion,\n    range: atom$Range,\n    diagnostics: Array<FileDiagnosticMessage>,\n  ): Promise<Array<CodeAction>>;\n\n  typeHint(fileVersion: FileVersion, position: atom$Point): Promise<?TypeHint>;\n\n  highlight(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?Array<atom$Range>>;\n\n  formatSource(\n    fileVersion: FileVersion,\n    range: atom$Range,\n    options: FormatOptions,\n  ): Promise<?Array<TextEdit>>;\n\n  formatEntireFile(\n    fileVersion: FileVersion,\n    range: atom$Range,\n    options: FormatOptions,\n  ): Promise<?{\n    newCursor?: number,\n    formatted: string,\n  }>;\n\n  formatAtPosition(\n    fileVersion: FileVersion,\n    position: atom$Point,\n    triggerCharacter: string,\n    options: FormatOptions,\n  ): Promise<?Array<TextEdit>>;\n\n  getAdditionalLogFiles(\n    deadline: DeadlineRequest,\n  ): Promise<Array<AdditionalLogFile>>;\n\n  getEvaluationExpression(\n    fileVersion: FileVersion,\n    position: atom$Point,\n  ): Promise<?NuclideEvaluationExpression>;\n\n  supportsSymbolSearch(directories: Array<NuclideUri>): Promise<boolean>;\n\n  symbolSearch(\n    query: string,\n    directories: Array<NuclideUri>,\n  ): Promise<?Array<SymbolResult>>;\n\n  getProjectRoot(fileUri: NuclideUri): Promise<?NuclideUri>;\n\n  isFileInProject(fileUri: NuclideUri): Promise<boolean>;\n\n  getExpandedSelectionRange(\n    fileVersion: FileVersion,\n    currentSelection: atom$Range,\n  ): Promise<?atom$Range>;\n\n  getCollapsedSelectionRange(\n    fileVersion: FileVersion,\n    currentSelection: atom$Range,\n    originalCursorPosition: atom$Point,\n  ): Promise<?atom$Range>;\n\n  dispose(): void;\n}\n"]}