{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/FlowSingleProjectLanguageService.js"],"names":["processAutocompleteItem","groupParamNames","emptyDiagnosticsState","updateDiagnostics","getDiagnosticUpdates","logger","FlowSingleProjectLanguageService","constructor","root","execInfoContainer","fileCache","_root","_execInfoContainer","_process","dispose","allowServerRestart","getPathToRoot","getProjectRoot","fileUri","Promise","resolve","getServerStatusUpdates","getDefinition","filePath","buffer","position","match","line","row","column","options","input","getText","args","result","execFlow","json","parseJSON","stdout","path","loc","file","point","start","queryRange","range","definitions","language","e","highlight","isSupported","getVersion","satisfies","_findRefs","type","references","map","ref","global_","push","convertFindRefsOutput","error","String","message","getDiagnostics","_forceRecheck","supportsFriendlyStatusError","jsonFlag","exitCode","undefined","diagnostics","filePathToMessages","Map","diagnostic","diagnosticArray","get","set","observeDiagnostics","ideConnections","getIDEConnections","switchMap","ideConnection","of","scan","concatMap","catch","err","getAutocompleteSuggestions","activatedManually","prefix","replacementPrefix","minimumPrefixLength","prefixHasDot","lineForRow","charAt","indexOf","length","contents","getCurrentIDEConnection","isIncomplete","items","resultsArray","completions","item","typeHint","character","getTextInRange","output","typeString","getCoverage","expressions","uncoveredCount","uncovered_count","coveredCount","covered_count","totalCount","uncoveredRegions","uncovered_locs","percentage","getOutline","flowGetAst","currentContents","flowRootPath","execFlowClient","warn","getCodeActions","Error","getAdditionalLogFiles","deadline","formatSource","formatEntireFile","formatAtPosition","triggerCharacter","findReferences","fromPromise","getEvaluationExpression","isFileInProject","getExpandedSelectionRange","currentSelection","getCollapsedSelectionRange","originalCursorPosition","value","JSON","parse","join","flowItem","description","substring","displayText","name","funcDetails","func_details","rightParamStrings","params","param","snippetArgs","getSnippetString","leftLabel","return_type","rightLabel","snippet","text","paramNames","groupedParams","snippetParamStrings","i","reduceRight","ordinary","optional","isOptional","unshift","ordinaryParams","trailingOptional","lastParam","lastChar","isInRecheck","staleMessages","currentMessages","filesToUpdate","Set","state","msg","keys","kind","newErrors","collateDiagnostics","errors","newMessages","messages","entries","oldMessages","stale","updates","locsToReferences","locs","end","uri","source","Array","isArray","baseUri","referencedSymbolName"],"mappings":"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","file":"FlowSingleProjectLanguageService.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport {wordAtPositionFromBuffer} from 'nuclide-commons/range';\nimport type {DeadlineRequest} from 'nuclide-commons/promise';\nimport type {AdditionalLogFile} from '../../nuclide-logging/lib/rpc-types';\nimport type {CoverageResult} from '../../nuclide-type-coverage/lib/rpc-types';\nimport type {\n  AutocompleteResult,\n  Completion,\n  FileDiagnosticMap,\n  FileDiagnosticMessage,\n} from '../../nuclide-language-service/lib/LanguageService';\nimport type {\n  DefinitionQueryResult,\n  FindReferencesReturn,\n  Reference,\n  Outline,\n  CodeAction,\n} from 'atom-ide-ui';\nimport type {SingleFileLanguageService} from '../../nuclide-language-service-rpc';\nimport type {NuclideEvaluationExpression} from 'nuclide-debugger-common';\nimport type {TextEdit} from 'nuclide-commons-atom/text-edit';\nimport type {TypeHint} from '../../nuclide-type-hint/lib/rpc-types';\n\nimport type {PushDiagnosticsMessage} from './FlowIDEConnection';\n\nimport type {ServerStatusType} from '..';\nimport type {FlowExecInfoContainer} from './FlowExecInfoContainer';\nimport type {\n  FlowAutocompleteOutput,\n  FlowAutocompleteItem,\n  TypeAtPosOutput,\n  FlowStatusOutput,\n  FindRefsOutput,\n  FlowLoc,\n} from './flowOutputTypes';\n\nimport invariant from 'assert';\nimport {Range, Point} from 'simple-text-buffer';\nimport {typeHintFromSnippet} from '../../nuclide-language-service-rpc';\nimport {getConfig} from './config';\nimport {Observable} from 'rxjs';\n\nimport {setUnion, mapGetWithDefault} from 'nuclide-commons/collection';\nimport {\n  filterResultsByPrefix,\n  getReplacementPrefix,\n  JAVASCRIPT_WORD_REGEX,\n} from '../../nuclide-flow-common';\nimport {getLogger} from 'log4js';\nconst logger = getLogger('nuclide-flow-rpc');\n\nimport {flowCoordsToAtomCoords} from '../../nuclide-flow-common';\n\nimport {FlowProcess} from './FlowProcess';\nimport prettyPrintTypes from './prettyPrintTypes';\nimport {astToOutline} from './astToOutline';\nimport {flowStatusOutputToDiagnostics} from './diagnosticsParser';\n\nimport type {FileCache} from '../../nuclide-open-files-rpc';\n\n/** Encapsulates all of the state information we need about a specific Flow root */\nexport class FlowSingleProjectLanguageService {\n  // The path to the directory where the .flowconfig is -- i.e. the root of the Flow project.\n  _root: string;\n  _process: FlowProcess;\n  _execInfoContainer: FlowExecInfoContainer;\n\n  constructor(\n    root: string,\n    execInfoContainer: FlowExecInfoContainer,\n    fileCache: FileCache,\n  ) {\n    this._root = root;\n    this._execInfoContainer = execInfoContainer;\n    this._process = new FlowProcess(root, execInfoContainer, fileCache);\n  }\n\n  dispose(): void {\n    this._process.dispose();\n  }\n\n  allowServerRestart(): void {\n    this._process.allowServerRestart();\n  }\n\n  getPathToRoot(): string {\n    return this._root;\n  }\n\n  getProjectRoot(fileUri: NuclideUri): Promise<?NuclideUri> {\n    // TODO Consider an invariant to assert that fileUri is inside this root. However, that should\n    // never happen since this will be enclosed by MultiProjectLanguageService which will dispatch\n    // to the correct instance of this class.\n    return Promise.resolve(this._root);\n  }\n\n  getServerStatusUpdates(): Observable<ServerStatusType> {\n    return this._process.getServerStatusUpdates();\n  }\n\n  async getDefinition(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?DefinitionQueryResult> {\n    const match = wordAtPositionFromBuffer(\n      buffer,\n      position,\n      JAVASCRIPT_WORD_REGEX,\n    );\n    if (match == null) {\n      return null;\n    }\n    const line = position.row + 1;\n    const column = position.column + 1;\n    const options = {};\n    // We pass the current contents of the buffer to Flow via stdin.\n    // This makes it possible for get-def to operate on the unsaved content in\n    // the user's editor rather than what is saved on disk. It would be annoying\n    // if the user had to save before using the jump-to-definition feature to\n    // ensure he or she got accurate results.\n    options.input = buffer.getText();\n\n    const args = ['get-def', '--json', '--path', filePath, line, column];\n    try {\n      const result = await this._process.execFlow(args, options);\n      if (!result) {\n        return null;\n      }\n      const json = parseJSON(args, result.stdout);\n      if (json.path) {\n        const loc = {\n          file: json.path,\n          point: new Point(json.line - 1, json.start - 1),\n        };\n        return {\n          queryRange: [match.range],\n          definitions: [\n            {\n              path: loc.file,\n              position: loc.point,\n              language: 'Flow',\n            },\n          ],\n        };\n      } else {\n        return null;\n      }\n    } catch (e) {\n      return null;\n    }\n  }\n\n  async highlight(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?Array<atom$Range>> {\n    // `flow find-refs` did not work well until version v0.55.0\n    const isSupported = await this._process.getVersion().satisfies('>=0.55.0');\n    if (!isSupported) {\n      return null;\n    }\n    const result = await this._findRefs(filePath, buffer, position, false);\n    if (result == null || result.type === 'error') {\n      return null;\n    }\n    return result.references.map(ref => ref.range);\n  }\n\n  async _findRefs(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n    global_: boolean,\n  ): Promise<?FindReferencesReturn> {\n    const options = {input: buffer.getText()};\n    const args = [\n      'find-refs',\n      '--json',\n      '--path',\n      filePath,\n      position.row + 1,\n      position.column + 1,\n    ];\n    if (global_) {\n      args.push('--global');\n    }\n    try {\n      const result = await this._process.execFlow(args, options);\n      if (result == null) {\n        return null;\n      }\n      const json: FindRefsOutput = parseJSON(args, result.stdout);\n      return convertFindRefsOutput(json, this._root);\n    } catch (e) {\n      logger.error(`flowFindRefs error: ${String(e)}`);\n      return {\n        type: 'error',\n        message: String(e),\n      };\n    }\n  }\n\n  /**\n   * If currentContents is null, it means that the file has not changed since\n   * it has been saved, so we can avoid piping the whole contents to the Flow\n   * process.\n   */\n  async getDiagnostics(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n  ): Promise<?FileDiagnosticMap> {\n    await this._forceRecheck(filePath);\n\n    const options = {};\n\n    const supportsFriendlyStatusError = await this._process\n      .getVersion()\n      .satisfies('>=0.66.0');\n    const jsonFlag = supportsFriendlyStatusError\n      ? ['--json', '--json-version', '2']\n      : ['--json'];\n    const args = ['status', ...jsonFlag, filePath];\n\n    let result;\n\n    try {\n      // Don't log errors if the command returns a nonzero exit code, because status returns nonzero\n      // if it is reporting any issues, even when it succeeds.\n      result = await this._process.execFlow(\n        args,\n        options,\n        /* waitForServer */ true,\n      );\n      if (!result) {\n        return null;\n      }\n    } catch (e) {\n      // This codepath will be exercised when Flow finds type errors as the\n      // exit code will be non-zero. Note this codepath could also be exercised\n      // due to a logical error in Nuclide, so we try to differentiate.\n      if (e.exitCode !== undefined) {\n        result = e;\n      } else {\n        logger.error(e);\n        return null;\n      }\n    }\n\n    let json;\n    try {\n      json = parseJSON(args, result.stdout);\n    } catch (e) {\n      return null;\n    }\n\n    const diagnostics = flowStatusOutputToDiagnostics(json);\n\n    const filePathToMessages = new Map();\n\n    for (const diagnostic of diagnostics) {\n      const path = diagnostic.filePath;\n      let diagnosticArray = filePathToMessages.get(path);\n      if (!diagnosticArray) {\n        diagnosticArray = [];\n        filePathToMessages.set(path, diagnosticArray);\n      }\n      diagnosticArray.push(diagnostic);\n    }\n\n    return filePathToMessages;\n  }\n\n  observeDiagnostics(): Observable<FileDiagnosticMap> {\n    const ideConnections = this._process.getIDEConnections();\n    return ideConnections\n      .switchMap(ideConnection => {\n        if (ideConnection != null) {\n          return ideConnection.observeDiagnostics();\n        } else {\n          // if ideConnection is null, it means there is currently no connection. So, invalidate the\n          // current diagnostics so we don't display stale data.\n          return Observable.of(null);\n        }\n      })\n      .scan(updateDiagnostics, emptyDiagnosticsState())\n      .concatMap(getDiagnosticUpdates)\n      .catch(err => {\n        logger.error(err);\n        throw err;\n      });\n  }\n\n  async getAutocompleteSuggestions(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n    activatedManually: boolean,\n    prefix: string,\n  ): Promise<?AutocompleteResult> {\n    const replacementPrefix = getReplacementPrefix(prefix);\n    // We may want to make this configurable, but if it is ever higher than one we need to make sure\n    // it works properly when the user manually activates it (e.g. with ctrl+space). See\n    // https://github.com/atom/autocomplete-plus/issues/597\n    //\n    // If this is made configurable, consider using autocomplete-plus' minimumWordLength setting, as\n    // per https://github.com/atom/autocomplete-plus/issues/594\n    const minimumPrefixLength = 1;\n\n    // Allows completions to immediately appear when we are completing off of object properties.\n    // This also needs to be changed if minimumPrefixLength goes above 1, since after you type a\n    // single alphanumeric character, autocomplete-plus no longer includes the dot in the prefix.\n    const prefixHasDot =\n      // charAt(index) returns an empty string if the index is out of bounds\n      buffer.lineForRow(position.row).charAt(position.column - 1) === '.' ||\n      prefix.indexOf('.') !== -1;\n\n    if (\n      !activatedManually &&\n      !prefixHasDot &&\n      replacementPrefix.length < minimumPrefixLength\n    ) {\n      return null;\n    }\n\n    // Note that Atom coordinates are 0-indexed whereas Flow's are 1-indexed, so we must add 1.\n    const line = position.row + 1;\n    const column = position.column + 1;\n    const contents = buffer.getText();\n    try {\n      let json: FlowAutocompleteOutput;\n      const ideConnection = this._process.getCurrentIDEConnection();\n      if (\n        ideConnection != null &&\n        (await this._process.getVersion().satisfies('>=0.48.0'))\n      ) {\n        json = await ideConnection.getAutocompleteSuggestions(\n          filePath,\n          line,\n          column,\n          contents,\n        );\n      } else {\n        const args = ['autocomplete', '--json', filePath, line, column];\n        const options = {input: contents};\n\n        const result = await this._process.execFlow(args, options);\n        if (!result) {\n          return {isIncomplete: false, items: []};\n        }\n        json = (parseJSON(args, result.stdout): FlowAutocompleteOutput);\n      }\n      const resultsArray: Array<FlowAutocompleteItem> = json.result;\n      const completions = resultsArray.map(item =>\n        processAutocompleteItem(replacementPrefix, item),\n      );\n      return filterResultsByPrefix(prefix, {\n        isIncomplete: false,\n        items: completions,\n      });\n    } catch (e) {\n      return {isIncomplete: false, items: []};\n    }\n  }\n\n  async typeHint(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?TypeHint> {\n    // Do not show typehints for whitespace.\n    const character = buffer.getTextInRange([\n      position,\n      {\n        row: position.row,\n        column: position.column + 1,\n      },\n    ]);\n    if (character.match(/\\s/)) {\n      return null;\n    }\n\n    const options = {};\n\n    options.input = buffer.getText();\n\n    const line = position.row + 1;\n    const column = position.column + 1;\n    const args = ['type-at-pos', '--json', '--path', filePath, line, column];\n\n    let result;\n    try {\n      result = await this._process.execFlow(args, options);\n    } catch (e) {\n      result = null;\n    }\n    if (!result) {\n      return null;\n    }\n    const output = result.stdout;\n\n    let json;\n    try {\n      json = (parseJSON(args, output): TypeAtPosOutput);\n    } catch (e) {\n      return null;\n    }\n    const type = json.type;\n    const range = flowCoordsToAtomCoords(json.loc);\n    if (!type || type === '(unknown)') {\n      return null;\n    }\n    let typeString;\n    try {\n      typeString = prettyPrintTypes(type);\n    } catch (e) {\n      logger.error(`Problem pretty printing type hint: ${e.message}`);\n      typeString = type;\n    }\n    return typeHintFromSnippet(typeString, range);\n  }\n\n  async getCoverage(filePath: NuclideUri): Promise<?CoverageResult> {\n    const args = ['coverage', '--json', filePath];\n    let result;\n    try {\n      result = await this._process.execFlow(args, {});\n    } catch (e) {\n      return null;\n    }\n    if (result == null) {\n      return null;\n    }\n    let json;\n    try {\n      json = parseJSON(args, result.stdout);\n    } catch (e) {\n      // The error is already logged in parseJSON\n      return null;\n    }\n\n    const expressions = json.expressions;\n\n    const uncoveredCount = expressions.uncovered_count;\n    const coveredCount = expressions.covered_count;\n    const totalCount = uncoveredCount + coveredCount;\n\n    const uncoveredRegions = expressions.uncovered_locs\n      .map(flowCoordsToAtomCoords)\n      .map(range => ({range}));\n\n    return {\n      percentage: totalCount === 0 ? 100 : coveredCount / totalCount * 100,\n      uncoveredRegions,\n    };\n  }\n\n  async _forceRecheck(file: string): Promise<boolean> {\n    try {\n      await this._process.execFlow(\n        ['force-recheck', file],\n        /* options */ {},\n        // Make an attempt to force a recheck, but if the server is busy don't insist.\n        /* waitsForServer */ false,\n        /* suppressErrors */ true,\n      );\n      return true;\n    } catch (e) {\n      // This command was introduced in Flow v0.23, so silently swallow errors to avoid logspam on\n      // earlier versions, until we want to break support for earlier version.\n      return false;\n    }\n  }\n\n  getOutline(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n  ): Promise<?Outline> {\n    return FlowSingleProjectLanguageService.getOutline(\n      filePath,\n      buffer,\n      this,\n      this._execInfoContainer,\n    );\n  }\n\n  // This static function takes an optional FlowRoot instance so that *if* it is part of a Flow\n  // root, it can use the appropriate flow-bin installation (which may be the only Flow\n  // installation) but if it lives outside of a Flow root, outlining still works using the system\n  // Flow.\n  static async getOutline(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    root: ?FlowSingleProjectLanguageService,\n    execInfoContainer: FlowExecInfoContainer,\n  ): Promise<?Outline> {\n    const json = await FlowSingleProjectLanguageService.flowGetAst(\n      root,\n      buffer.getText(),\n      execInfoContainer,\n    );\n\n    try {\n      return json ? astToOutline(json) : null;\n    } catch (e) {\n      // Traversing the AST is an error-prone process and it's hard to be sure we've handled all the\n      // cases. Fail gracefully if it does not work.\n      logger.error(e);\n      return null;\n    }\n  }\n\n  static async flowGetAst(\n    root: ?FlowSingleProjectLanguageService,\n    currentContents: string,\n    execInfoContainer: FlowExecInfoContainer,\n  ): Promise<any> {\n    const options = {\n      input: currentContents,\n    };\n\n    const flowRootPath = root == null ? null : root.getPathToRoot();\n\n    const args = ['ast'];\n\n    let json;\n    try {\n      const result = await FlowProcess.execFlowClient(\n        args,\n        flowRootPath,\n        execInfoContainer,\n        options,\n      );\n      if (result == null) {\n        return null;\n      }\n      json = parseJSON(args, result.stdout);\n    } catch (e) {\n      logger.warn(e);\n      return null;\n    }\n    return json;\n  }\n\n  getCodeActions(\n    filePath: NuclideUri,\n    range: atom$Range,\n    diagnostics: Array<FileDiagnosticMessage>,\n  ): Promise<Array<CodeAction>> {\n    throw new Error('Not implemeneted');\n  }\n\n  async getAdditionalLogFiles(\n    deadline: DeadlineRequest,\n  ): Promise<Array<AdditionalLogFile>> {\n    return [];\n  }\n\n  formatSource(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    range: atom$Range,\n  ): Promise<?Array<TextEdit>> {\n    throw new Error('Not Yet Implemented');\n  }\n\n  formatEntireFile(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    range: atom$Range,\n  ): Promise<?{\n    newCursor?: number,\n    formatted: string,\n  }> {\n    throw new Error('Not implemented');\n  }\n\n  formatAtPosition(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n    triggerCharacter: string,\n  ): Promise<?Array<TextEdit>> {\n    throw new Error('Not Yet Implemented');\n  }\n\n  findReferences(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Observable<?FindReferencesReturn> {\n    // TODO check flow version\n    return Observable.fromPromise(\n      this._findRefs(filePath, buffer, position, true),\n    );\n  }\n\n  getEvaluationExpression(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    position: atom$Point,\n  ): Promise<?NuclideEvaluationExpression> {\n    throw new Error('Not implemented');\n  }\n\n  isFileInProject(fileUri: NuclideUri): Promise<boolean> {\n    throw new Error('Not Yet Implemented');\n  }\n\n  getExpandedSelectionRange(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    currentSelection: atom$Range,\n  ): Promise<?atom$Range> {\n    throw new Error('Not Yet Implemented');\n  }\n\n  getCollapsedSelectionRange(\n    filePath: NuclideUri,\n    buffer: simpleTextBuffer$TextBuffer,\n    currentSelection: atom$Range,\n    originalCursorPosition: atom$Point,\n  ): Promise<?atom$Range> {\n    throw new Error('Not Yet Implemented');\n  }\n}\n\n// FlowSingleProjectLanguageService should satisfy the SingleFileLanguageService interface\n(((null: any): FlowSingleProjectLanguageService): SingleFileLanguageService);\n\nfunction parseJSON(args: Array<any>, value: string): any {\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    logger.warn(\n      `Invalid JSON result from flow ${args.join(' ')}. JSON:\\n'${value}'.`,\n    );\n    throw e;\n  }\n}\n\n/**\n * Takes an autocomplete item from Flow and returns a valid autocomplete-plus\n * response, as documented here:\n * https://github.com/atom/autocomplete-plus/wiki/Provider-API\n */\nexport function processAutocompleteItem(\n  replacementPrefix: string,\n  flowItem: FlowAutocompleteItem,\n): Completion {\n  // Truncate long types for readability\n  const description =\n    flowItem.type.length < 80\n      ? flowItem.type\n      : flowItem.type.substring(0, 80) + ' ...';\n  let result = {\n    description,\n    displayText: flowItem.name,\n    replacementPrefix,\n  };\n  const funcDetails = flowItem.func_details;\n  if (funcDetails) {\n    // The parameters in human-readable form for use on the right label.\n    const rightParamStrings = funcDetails.params.map(\n      param => `${param.name}: ${param.type}`,\n    );\n    let snippetArgs = `(${getSnippetString(\n      funcDetails.params.map(param => param.name),\n    )})`;\n    let leftLabel = funcDetails.return_type;\n    let rightLabel = `(${rightParamStrings.join(', ')})`;\n    if (!getConfig('functionSnippetShouldIncludeArguments')) {\n      snippetArgs = '';\n      leftLabel = undefined;\n      rightLabel += ` => ${funcDetails.return_type}`;\n    }\n    result = {\n      ...result,\n      leftLabel,\n      rightLabel,\n      snippet: `${flowItem.name}${snippetArgs}`,\n      type: 'function',\n    };\n  } else {\n    result = {\n      ...result,\n      rightLabel: flowItem.type,\n      text: flowItem.name,\n    };\n  }\n  return result;\n}\n\nfunction getSnippetString(paramNames: Array<string>): string {\n  const groupedParams = groupParamNames(paramNames);\n  // The parameters turned into snippet strings.\n  const snippetParamStrings = groupedParams\n    .map(params => params.join(', '))\n    .map((param, i) => `\\${${i + 1}:${param}}`);\n  return snippetParamStrings.join(', ');\n}\n\n/**\n * Group the parameter names so that all of the trailing optional parameters are together with the\n * last non-optional parameter. That makes it easy to ignore the optional parameters, since they\n * will be selected along with the last non-optional parameter and you can just type to overwrite\n * them.\n */\n// Exported for testing\nexport function groupParamNames(\n  paramNames: Array<string>,\n): Array<Array<string>> {\n  // Split the parameters into two groups -- all of the trailing optional paramaters, and the rest\n  // of the parameters. Trailing optional means all optional parameters that have only optional\n  // parameters after them.\n  const [ordinaryParams, trailingOptional] = paramNames.reduceRight(\n    ([ordinary, optional], param) => {\n      // If there have only been optional params so far, and this one is optional, add it to the\n      // list of trailing optional params.\n      if (isOptional(param) && ordinary.length === 0) {\n        optional.unshift(param);\n      } else {\n        ordinary.unshift(param);\n      }\n      return [ordinary, optional];\n    },\n    [[], []],\n  );\n\n  const groupedParams = ordinaryParams.map(param => [param]);\n  const lastParam = groupedParams[groupedParams.length - 1];\n  if (lastParam != null) {\n    lastParam.push(...trailingOptional);\n  } else if (trailingOptional.length > 0) {\n    groupedParams.push(trailingOptional);\n  }\n\n  return groupedParams;\n}\n\nfunction isOptional(param: string): boolean {\n  invariant(param.length > 0);\n  const lastChar = param[param.length - 1];\n  return lastChar === '?';\n}\n\n// This should be immutable, but lacking good immutable data structure implementations, we are just\n// going to mutate it\n// Exported only for testing\nexport type DiagnosticsState = {\n  isInRecheck: boolean,\n  // Stale messages from the last recheck. We still want to display these, but as soon as the\n  // recheck ends we should invalidate them.\n  // invariants: empty if we are not in a recheck, all contained messages have `stale: true`.\n  staleMessages: Map<NuclideUri, Array<FileDiagnosticMessage>>,\n  // All the currently-valid diagnostic messages. During a recheck, incoming messages get\n  // accumulated here.\n  currentMessages: Map<NuclideUri, Array<FileDiagnosticMessage>>,\n  // All the files that need to be updated immediately. May include files that do not exist in\n  // allCurrentMessages, meaning that there are no associated messages and we just need to clear the\n  // previous errors.\n  filesToUpdate: Set<NuclideUri>,\n};\n\n// Exported only for testing\nexport function emptyDiagnosticsState(): DiagnosticsState {\n  return {\n    isInRecheck: false,\n    staleMessages: new Map(),\n    currentMessages: new Map(),\n    filesToUpdate: new Set(),\n  };\n}\n\n// Exported only for testing\nexport function updateDiagnostics(\n  state: DiagnosticsState,\n  // null means we have received a null ide connection (meaning the previous one has gone away)\n  msg: ?PushDiagnosticsMessage,\n): DiagnosticsState {\n  if (msg == null) {\n    return {\n      isInRecheck: false,\n      staleMessages: new Map(),\n      currentMessages: new Map(),\n      filesToUpdate: setUnion(\n        new Set(state.staleMessages.keys()),\n        new Set(state.currentMessages.keys()),\n      ),\n    };\n  }\n  switch (msg.kind) {\n    case 'errors':\n      const newErrors = collateDiagnostics(msg.errors);\n      if (state.isInRecheck) {\n        // Yes we are going to mutate this :(\n        const {currentMessages} = state;\n        for (const [file, newMessages] of newErrors) {\n          let messages = currentMessages.get(file);\n          if (messages == null) {\n            messages = [];\n            currentMessages.set(file, messages);\n          }\n          messages.push(...newMessages);\n        }\n        return {\n          isInRecheck: state.isInRecheck,\n          staleMessages: state.staleMessages,\n          currentMessages,\n          filesToUpdate: new Set(newErrors.keys()),\n        };\n      } else {\n        // Update the files that now have errors, and those that had errors the last time (we need\n        // to make sure to remove errors that no longer exist).\n        const filesToUpdate = setUnion(\n          new Set(newErrors.keys()),\n          new Set(state.currentMessages.keys()),\n        );\n        return {\n          isInRecheck: state.isInRecheck,\n          staleMessages: state.staleMessages,\n          currentMessages: newErrors,\n          filesToUpdate,\n        };\n      }\n    case 'start-recheck':\n      const staleMessages = new Map();\n      for (const [file, oldMessages] of state.currentMessages.entries()) {\n        const messages = oldMessages.map(\n          message =>\n            ({\n              ...message,\n              stale: true,\n            }: any),\n        );\n        staleMessages.set(file, messages);\n      }\n      return {\n        isInRecheck: true,\n        staleMessages,\n        currentMessages: new Map(),\n        filesToUpdate: new Set(state.currentMessages.keys()),\n      };\n    case 'end-recheck':\n      return {\n        isInRecheck: false,\n        staleMessages: new Map(),\n        currentMessages: state.currentMessages,\n        filesToUpdate: new Set(state.staleMessages.keys()),\n      };\n    default:\n      // Enforce exhaustiveness\n      (msg.kind: empty);\n      throw new Error(`Unknown message kind ${msg.kind}`);\n  }\n}\n\n// Exported only for testing\nexport function getDiagnosticUpdates(\n  state: DiagnosticsState,\n): Observable<FileDiagnosticMap> {\n  const updates = new Map();\n  for (const file of state.filesToUpdate) {\n    const messages = [\n      ...mapGetWithDefault(state.staleMessages, file, []),\n      ...mapGetWithDefault(state.currentMessages, file, []),\n    ];\n    updates.set(file, messages);\n  }\n  return Observable.of(updates);\n}\n\nfunction collateDiagnostics(output: FlowStatusOutput): FileDiagnosticMap {\n  const diagnostics = flowStatusOutputToDiagnostics(output);\n  const filePathToMessages = new Map();\n\n  for (const diagnostic of diagnostics) {\n    const path = diagnostic.filePath;\n    let diagnosticArray = filePathToMessages.get(path);\n    if (!diagnosticArray) {\n      diagnosticArray = [];\n      filePathToMessages.set(path, diagnosticArray);\n    }\n    diagnosticArray.push(diagnostic);\n  }\n  return filePathToMessages;\n}\n\nfunction locsToReferences(locs: Array<FlowLoc>): Array<Reference> {\n  return locs.map(loc => {\n    return {\n      name: null,\n      range: new Range(\n        new Point(loc.start.line - 1, loc.start.column - 1),\n        new Point(loc.end.line - 1, loc.end.column),\n      ),\n      uri: loc.source,\n    };\n  });\n}\n\nfunction convertFindRefsOutput(\n  output: FindRefsOutput,\n  root: string,\n): FindReferencesReturn {\n  if (Array.isArray(output)) {\n    return {\n      type: 'data',\n      baseUri: root,\n      referencedSymbolName: '',\n      references: locsToReferences(output),\n    };\n  } else {\n    if (output.kind === 'no-symbol-found') {\n      return {\n        type: 'error',\n        message: 'No symbol found at the current location by Flow.',\n      };\n    } else {\n      return {\n        type: 'data',\n        baseUri: root,\n        referencedSymbolName: output.name,\n        references: locsToReferences(output.locs),\n      };\n    }\n  }\n}\n"]}