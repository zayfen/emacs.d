{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/FlowIDEConnection.js"],"names":["rpc","SUBSCRIBE_METHOD_NAME","NOTIFICATION_METHOD_NAME","OPEN_EVENT_METHOD_NAME","CLOSE_EVENT_METHOD_NAME","SUBSCRIBE_RETRY_INTERVAL","SUBSCRIBE_RETRIES","FlowIDEConnection","constructor","process","fileCache","_disposables","_fileCache","_ideProcess","stderr","pipe","msg","info","toString","_connection","createMessageConnection","stdout","StreamMessageWriter","stdin","listen","on","dispose","diagnostics","fromEventPattern","handler","onNotification","errors","_diagnostics","using","fileEventsObservable","observeFileEvents","bufferTime","filter","fileEvents","length","fileEventsHandler","openPaths","closePaths","fileEvent","filePath","fileVersion","kind","OPEN","push","CLOSE","EDIT","SAVE","sendNotification","subscribe","publishReplay","add","connect","_recheckBookends","publish","end","kill","onWillDispose","callback","remove","observeDiagnostics","retrySubscription","interval","take","takeUntil","error","merge","map","observeRecheckBookends","getAutocompleteSuggestions","line","column","contents","sendRequest"],"mappings":"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","file":"FlowIDEConnection.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\nimport type {FlowStatusOutput, FlowAutocompleteOutput} from './flowOutputTypes';\nimport type {FileCache} from '../../nuclide-open-files-rpc';\nimport type {LocalFileEvent} from '../../nuclide-open-files-rpc/lib/rpc-types';\n\nimport {Observable} from 'rxjs';\nimport * as rpc from 'vscode-jsonrpc';\nimport through from 'through';\n\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\nimport SafeStreamMessageReader from 'nuclide-commons/SafeStreamMessageReader';\nimport {track} from '../../nuclide-analytics';\nimport {getLogger} from 'log4js';\n\nimport {FileEventKind} from '../../nuclide-open-files-rpc';\n\n// TODO put these in flow-typed when they are fleshed out better\n\ntype MessageHandler = (...args: any) => mixed;\n\ntype RpcConnection = {\n  onNotification(methodName: string, handler: MessageHandler): void,\n  sendNotification(methodName: string, ...args: any): void,\n  sendRequest(methodName: string, ...args: any): Promise<any>,\n  // TODO requests\n  listen(): void,\n  dispose(): void,\n};\n\nexport type PushDiagnosticsMessage =\n  | RecheckBookend\n  | {\n      kind: 'errors',\n      errors: FlowStatusOutput,\n    };\n\nexport type RecheckBookend =\n  | {\n      kind: 'start-recheck',\n    }\n  | {\n      kind: 'end-recheck',\n    };\n\nconst SUBSCRIBE_METHOD_NAME = 'subscribeToDiagnostics';\n\nconst NOTIFICATION_METHOD_NAME = 'diagnosticsNotification';\n\nconst OPEN_EVENT_METHOD_NAME = 'didOpen';\nconst CLOSE_EVENT_METHOD_NAME = 'didClose';\n\nconst SUBSCRIBE_RETRY_INTERVAL = 5000;\nconst SUBSCRIBE_RETRIES = 10;\n\n// Manages the connection to a single `flow ide` process. The lifecycle of an instance of this class\n// is tied to the lifecycle of the `flow ide` process.\nexport class FlowIDEConnection {\n  _connection: RpcConnection;\n  _ideProcess: child_process$ChildProcess;\n  _disposables: UniversalDisposable;\n\n  // Because vscode-jsonrpc offers no mechanism to unsubscribe from notifications, we have to make\n  // sure that we put a bound on the number of times we add subscriptions, otherwise we could have a\n  // memory leak. The most sensible bound is to just allow a single subscription per message type.\n  // Therefore, we must have singleton observables rather than returning new instances from method\n  // calls.\n  _diagnostics: Observable<FlowStatusOutput>;\n  _recheckBookends: Observable<RecheckBookend>;\n\n  _fileCache: FileCache;\n\n  constructor(process: child_process$ChildProcess, fileCache: FileCache) {\n    this._disposables = new UniversalDisposable();\n    this._fileCache = fileCache;\n    this._ideProcess = process;\n    this._ideProcess.stderr.pipe(\n      through(msg => {\n        getLogger('nuclide-flow-rpc').info(\n          'Flow IDE process stderr: ',\n          msg.toString(),\n        );\n      }),\n    );\n    this._connection = rpc.createMessageConnection(\n      new SafeStreamMessageReader(this._ideProcess.stdout),\n      new rpc.StreamMessageWriter(this._ideProcess.stdin),\n    );\n    this._connection.listen();\n\n    this._ideProcess.on('exit', () => this.dispose());\n    this._ideProcess.on('close', () => this.dispose());\n\n    const diagnostics = Observable.fromEventPattern(\n      handler => {\n        this._connection.onNotification(\n          NOTIFICATION_METHOD_NAME,\n          (errors: FlowStatusOutput) => {\n            handler(errors);\n          },\n        );\n      },\n      // no-op: vscode-jsonrpc offers no way to unsubscribe\n      () => {},\n    );\n\n    this._diagnostics = Observable.using(() => {\n      const fileEventsObservable: Observable<\n        Array<LocalFileEvent>,\n      > = this._fileCache\n        .observeFileEvents()\n        .bufferTime(100 /* ms */)\n        .filter(fileEvents => fileEvents.length !== 0);\n\n      const fileEventsHandler = fileEvents => {\n        const openPaths: Array<string> = [];\n        const closePaths: Array<string> = [];\n        for (const fileEvent of fileEvents) {\n          const filePath = fileEvent.fileVersion.filePath;\n          switch (fileEvent.kind) {\n            case FileEventKind.OPEN:\n              openPaths.push(filePath);\n              break;\n            case FileEventKind.CLOSE:\n              closePaths.push(filePath);\n              break;\n            case FileEventKind.EDIT:\n              // TODO: errors-as-you-type\n              break;\n            case FileEventKind.SAVE:\n              // TODO: handle saves correctly\n              break;\n            default:\n              (fileEvent.kind: empty);\n          }\n        }\n        if (openPaths.length !== 0) {\n          this._connection.sendNotification(OPEN_EVENT_METHOD_NAME, openPaths);\n        }\n        if (closePaths.length !== 0) {\n          this._connection.sendNotification(\n            CLOSE_EVENT_METHOD_NAME,\n            closePaths,\n          );\n        }\n      };\n\n      return fileEventsObservable.subscribe(fileEventsHandler);\n    }, () => diagnostics).publishReplay(1);\n    this._disposables.add(this._diagnostics.connect());\n\n    this._recheckBookends = Observable.fromEventPattern(\n      handler => {\n        this._connection.onNotification('startRecheck', () => {\n          handler({kind: 'start-recheck'});\n        });\n        this._connection.onNotification('endRecheck', () => {\n          handler({kind: 'end-recheck'});\n        });\n      },\n      // no-op\n      () => {},\n    ).publish();\n    this._disposables.add(this._recheckBookends.connect());\n\n    this._disposables.add(() => {\n      this._ideProcess.stdin.end();\n      this._ideProcess.kill();\n\n      this._connection.dispose();\n    });\n  }\n\n  dispose(): void {\n    this._disposables.dispose();\n  }\n\n  onWillDispose(callback: () => mixed): IDisposable {\n    this._disposables.add(callback);\n    return new UniversalDisposable(() => {\n      this._disposables.remove(callback);\n    });\n  }\n\n  observeDiagnostics(): Observable<PushDiagnosticsMessage> {\n    const subscribe = () => {\n      this._connection.sendNotification(SUBSCRIBE_METHOD_NAME);\n    };\n\n    const retrySubscription = Observable.interval(SUBSCRIBE_RETRY_INTERVAL)\n      .take(SUBSCRIBE_RETRIES)\n      .takeUntil(this._diagnostics)\n      .subscribe(() => {\n        getLogger('nuclide-flow-rpc').error(\n          'Did not receive diagnostics after subscribe request -- retrying...',\n        );\n        track('nuclide-flow.missing-push-diagnostics');\n        subscribe();\n      });\n\n    subscribe();\n    return Observable.using(\n      () => retrySubscription,\n      () => {\n        return Observable.merge(\n          this._diagnostics.map(errors => ({kind: 'errors', errors})),\n          this._recheckBookends,\n        );\n      },\n    );\n  }\n\n  // Flow will not send these messages unless we have subscribed to diagnostics. So, this observable\n  // will never emit any items unless observeDiagnostics() is called.\n  observeRecheckBookends(): Observable<RecheckBookend> {\n    return this._recheckBookends;\n  }\n\n  getAutocompleteSuggestions(\n    filePath: NuclideUri,\n    line: number,\n    column: number,\n    contents: string,\n  ): Promise<FlowAutocompleteOutput> {\n    return this._connection.sendRequest(\n      'autocomplete',\n      filePath,\n      line,\n      column,\n      contents,\n    );\n  }\n}\n"]}