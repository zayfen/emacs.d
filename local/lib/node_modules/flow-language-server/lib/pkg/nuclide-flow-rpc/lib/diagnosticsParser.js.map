{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/diagnosticsParser.js"],"names":["flowStatusOutputToDiagnostics","diagnosticToFix","extractRange","BUILTIN_LOCATION","statusOutput","errors","map","error","classic","undefined","flowClassicMessageToDiagnosticMessage","flowFriendlyMessageToDiagnosticMessage","Error","diagnostic","fixExtractionFunctions","extractionFunction","fix","unusedSuppressionFix","namedImportTypo","isUnusedLegacySuppression","trace","length","text","isUnusedSuppresion","oldRange","range","newText","speculative","traceText","test","regex","match","exec","oldText","extractPath","message","loc","source","flowMessageToTrace","type","descr","filePath","flowStatusError","diagnosticMessage","providerName","level","getFriendlyText","messageMarkup","primaryLoc","getFriendlyTrace","referenceLocs","diagnostics","referenceId","push","Array","isArray","getText","kind","join","header","items","flowMessageComponents","mainMessage","path","find","extractedPath","extractTraces","slice","operation","operationComponent","extra","forEach","children","childrenTraces","concat","child","start","line","column","end"],"mappings":"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","file":"diagnosticsParser.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {DiagnosticFix, DiagnosticTrace} from 'atom-ide-ui';\nimport type {NuclideUri} from 'nuclide-commons/nuclideUri';\n\nimport type {FileDiagnosticMessage} from '../../nuclide-language-service/lib/LanguageService';\nimport type {\n  FlowStatusOutput,\n  FlowStatusErrorMessageComponent,\n  FlowClassicStatusError,\n  FlowFriendlyStatusError,\n  FlowFriendlyMessage,\n  FlowLoc,\n} from './flowOutputTypes';\n\nimport invariant from 'assert';\nimport {Range} from 'simple-text-buffer';\n\n// Flow sometimes reports this as the file path for an error. When this happens, we should simply\n// leave out the location, since it isn't very useful and it's not a well-formed path, which can\n// cause issues down the line.\nconst BUILTIN_LOCATION = '(builtins)';\n\nexport function flowStatusOutputToDiagnostics(\n  statusOutput: FlowStatusOutput,\n): Array<FileDiagnosticMessage> {\n  return statusOutput.errors.map(error => {\n    if (error.classic === undefined || error.classic === true) {\n      return flowClassicMessageToDiagnosticMessage(error);\n    }\n    if (error.classic === false) {\n      return flowFriendlyMessageToDiagnosticMessage(error);\n    }\n    throw new Error('Invalid flow status error type');\n  });\n}\n\n// Exported for testing\nexport function diagnosticToFix(\n  diagnostic: FileDiagnosticMessage,\n): ?DiagnosticFix {\n  for (const extractionFunction of fixExtractionFunctions) {\n    const fix = extractionFunction(diagnostic);\n    if (fix != null) {\n      return fix;\n    }\n  }\n\n  return null;\n}\n\nconst fixExtractionFunctions: Array<\n  (diagnostic: FileDiagnosticMessage) => ?DiagnosticFix,\n> = [unusedSuppressionFix, namedImportTypo];\n\nfunction unusedSuppressionFix(\n  diagnostic: FileDiagnosticMessage,\n): ?DiagnosticFix {\n  // Automatically remove unused suppressions:\n  const isUnusedLegacySuppression =\n    diagnostic.trace != null &&\n    diagnostic.trace.length === 1 &&\n    diagnostic.text === 'Error suppressing comment' &&\n    diagnostic.trace[0].text === 'Unused suppression';\n  const isUnusedSuppresion = diagnostic.text === 'Unused suppression comment.';\n  if (isUnusedSuppresion || isUnusedLegacySuppression) {\n    const oldRange = diagnostic.range;\n    invariant(oldRange != null);\n    return {\n      newText: '',\n      oldRange,\n      speculative: true,\n    };\n  }\n\n  return null;\n}\n\nfunction namedImportTypo(diagnostic: FileDiagnosticMessage): ?DiagnosticFix {\n  const trace = diagnostic.trace;\n  const text = diagnostic.text;\n  if (trace == null || trace.length !== 1 || text == null) {\n    return null;\n  }\n  const traceText = trace[0].text;\n  if (traceText == null) {\n    return null;\n  }\n\n  if (!/^Named import from module `[^`]*`$/.test(text)) {\n    return null;\n  }\n\n  const regex = /^This module has no named export called `([^`]*)`. Did you mean `([^`]*)`\\?$/;\n  const match = regex.exec(traceText);\n  if (match == null) {\n    return null;\n  }\n\n  const oldText = match[1];\n  const newText = match[2];\n  const oldRange = diagnostic.range;\n  invariant(oldRange != null);\n\n  return {\n    oldText,\n    newText,\n    oldRange,\n    speculative: true,\n  };\n}\n\n/**\n * Currently, a diagnostic from Flow is an object with a \"message\" property.\n * Each item in the \"message\" array is an object with the following fields:\n *     - path (string) File that contains the error.\n *     - descr (string) Description of the error.\n *     - line (number) Start line.\n *     - endline (number) End line.\n *     - start (number) Start column.\n *     - end (number) End column.\n *     - code (number) Presumably an error code.\n * The message array may have more than one item. For example, if there is a\n * type incompatibility error, the first item in the message array blames the\n * usage of the wrong type and the second blames the declaration of the type\n * with which the usage disagrees. Note that these could occur in different\n * files.\n */\n\nfunction extractPath(\n  message: FlowStatusErrorMessageComponent,\n): NuclideUri | void {\n  if (message.loc == null || message.loc.source === BUILTIN_LOCATION) {\n    return undefined;\n  }\n  return message.loc.source;\n}\n\n// A trace object is very similar to an error object.\nfunction flowMessageToTrace(\n  message: FlowStatusErrorMessageComponent,\n): DiagnosticTrace {\n  return {\n    type: 'Trace',\n    text: message.descr,\n    filePath: extractPath(message),\n    range: extractRange(message.loc),\n  };\n}\n\nfunction flowFriendlyMessageToDiagnosticMessage(\n  flowStatusError: FlowFriendlyStatusError,\n) {\n  const diagnosticMessage: FileDiagnosticMessage = {\n    providerName: 'Flow',\n    type: flowStatusError.level === 'error' ? 'Error' : 'Warning',\n    text: getFriendlyText(flowStatusError.messageMarkup),\n    filePath: flowStatusError.primaryLoc.source,\n    range: extractRange(flowStatusError.primaryLoc),\n    trace: getFriendlyTrace(flowStatusError.referenceLocs),\n  };\n\n  const fix = diagnosticToFix(diagnosticMessage);\n  if (fix != null) {\n    diagnosticMessage.fix = fix;\n  }\n  return diagnosticMessage;\n}\n\nfunction getFriendlyTrace(referenceLocs: {\n  [id: string]: FlowLoc,\n}): Array<DiagnosticTrace> {\n  const diagnostics = [];\n  for (const referenceId in referenceLocs) {\n    const loc = referenceLocs[referenceId];\n    diagnostics.push({\n      type: 'Trace',\n      text: `[${referenceId}]`,\n      filePath: loc.source,\n      range: extractRange(loc),\n    });\n  }\n  return diagnostics;\n}\n\nfunction getFriendlyText(messageMarkup: FlowFriendlyMessage): string {\n  if (Array.isArray(messageMarkup)) {\n    const getText = message => {\n      switch (message.kind) {\n        case 'Text':\n          return message.text;\n        case 'Code':\n          return `\\`${message.text}\\``;\n        case 'Reference':\n          return (\n            message.message.map(getText).join('') + ` [${message.referenceId}]`\n          );\n      }\n    };\n    return messageMarkup.map(getText).join('');\n  }\n\n  const header = getFriendlyText(messageMarkup.message);\n  const items = messageMarkup.items\n    .map(getFriendlyText)\n    .map(message => ` - ${message}`)\n    .join('\\n');\n  return `${header}\\n${items}`;\n}\n\nfunction flowClassicMessageToDiagnosticMessage(\n  flowStatusError: FlowClassicStatusError,\n) {\n  const flowMessageComponents: Array<FlowStatusErrorMessageComponent> =\n    flowStatusError.message;\n\n  const mainMessage = flowMessageComponents[0];\n\n  // The Flow type does not capture this, but the first message always has a path, and the\n  // diagnostics package requires a FileDiagnosticMessage to have a path.\n  const path = flowMessageComponents\n    .map(extractPath)\n    .find(extractedPath => extractedPath != null);\n  invariant(path != null, 'Expected path to not be null or undefined');\n\n  const diagnosticMessage: FileDiagnosticMessage = {\n    providerName: 'Flow',\n    type: flowStatusError.level === 'error' ? 'Error' : 'Warning',\n    text: mainMessage.descr,\n    filePath: path,\n    range: extractRange(mainMessage.loc),\n    trace: extractTraces(flowStatusError),\n  };\n\n  const fix = diagnosticToFix(diagnosticMessage);\n  if (fix != null) {\n    diagnosticMessage.fix = fix;\n  }\n\n  return diagnosticMessage;\n}\n\nfunction extractTraces(\n  flowStatusError: FlowClassicStatusError,\n): Array<DiagnosticTrace> | void {\n  const flowMessageComponents: Array<FlowStatusErrorMessageComponent> =\n    flowStatusError.message;\n\n  const trace: Array<DiagnosticTrace> = [];\n  // When the message is an array with multiple elements, the second element\n  // onwards comprise the trace for the error.\n  if (flowMessageComponents.length > 1) {\n    trace.push(...flowMessageComponents.slice(1).map(flowMessageToTrace));\n  }\n\n  const operation = flowStatusError.operation;\n  if (operation != null) {\n    const operationComponent = flowMessageToTrace(operation);\n    invariant(operationComponent.text != null);\n    operationComponent.text = 'See also: ' + operationComponent.text;\n    trace.push(operationComponent);\n  }\n  const extra = flowStatusError.extra;\n  if (extra != null) {\n    extra.forEach(({message, children}) => {\n      trace.push(...message.map(flowMessageToTrace));\n      if (children != null) {\n        const childrenTraces: Array<DiagnosticTrace> = [].concat(\n          ...children.map(child =>\n            [].concat(child.message.map(flowMessageToTrace)),\n          ),\n        );\n        trace.push(...childrenTraces);\n      }\n    });\n  }\n\n  if (trace.length > 0) {\n    return trace;\n  } else {\n    return undefined;\n  }\n}\n\n// Use `atom$Range | void` rather than `?atom$Range` to exclude `null`, so that the type is\n// compatible with the `range` property, which is an optional property rather than a nullable\n// property.\nexport function extractRange(loc: ?FlowLoc): atom$Range | void {\n  if (loc == null || loc.source === BUILTIN_LOCATION) {\n    return undefined;\n  } else {\n    // It's unclear why the 1-based to 0-based indexing works the way that it\n    // does, but this has the desired effect in the UI, in practice.\n    return new Range(\n      [loc.start.line - 1, loc.start.column - 1],\n      [loc.end.line - 1, loc.end.column],\n    );\n  }\n}\n"]}