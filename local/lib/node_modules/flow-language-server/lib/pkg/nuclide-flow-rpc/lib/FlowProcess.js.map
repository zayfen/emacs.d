{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/FlowProcess.js"],"names":["args","root","execInfoContainer","options","execInfo","getFlowExecInfo","execOptions","pathToFlow","getAllExecInfo","logger","FLOW_RETURN_CODES","ok","serverInitializing","typeError","noServerRunning","outOfRetries","buildIdMismatch","unexpectedArgument","SERVER_READY_TIMEOUT_MS","EXEC_FLOW_RETRIES","NO_RETRY_ARGS","TEMP_SERVER_STATES","NOT_RUNNING","BUSY","INIT","FlowProcess","constructor","fileCache","_subscriptions","_execInfoContainer","_serverStatus","UNKNOWN","_root","_isDisposed","_fileCache","_optionalIDEConnections","_ideConnections","_createIDEConnectionStream","subscribe","status","info","filter","x","_startFlowServer","scan","previousState","nextState","shouldStartPinging","includes","_pingServer","FAILED","_version","flowVersion","state","invalidateVersion","dispose","complete","next","_startedServer","kill","getVersion","allowServerRestart","getValue","getServerStatusUpdates","asObservable","getIDEConnections","getCurrentIDEConnection","add","conn","switchMap","observeRecheckBookends","bookend","kind","_setServerStatus","READY","isFailed","map","distinctUntilChanged","shouldStart","failed","mapTo","undefined","_createSingleIDEConnectionStream","takeUntil","concat","of","do","publishReplay","refCount","connectionWatcher","fromEventPattern","handler","_tryCreateIDEProcess","start","defer","_serverIsReady","serverIsReady","satisfies","then","supportsFriendlyStatusError","jsonFlag","allExecInfo","proc","once","code","signal","_updateServerStatus","execFlow","waitForServer","suppressErrors","maxRetries","i","result","_rawExecFlow","e","couldRetry","indexOf","error","join","JSON","stringify","flowExecInfo","reallyGetFlowExecInfo","NOT_INSTALLED","lazy","push","serverProcess","_getMaxWorkers","toString","logIt","pid","debug","data","stdout","on","stderr","args_","execFlowClient","exitCode","String","currentStatus","hasReachedSteadyState","take","_pingServerOnce","catch","race","delay","first","toPromise","Math","max","cpus","length"],"mappings":"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","file":"FlowProcess.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {ServerStatusType} from '..';\n\nimport type {FlowExecInfoContainer} from './FlowExecInfoContainer';\n\nimport os from 'os';\nimport invariant from 'assert';\nimport {BehaviorSubject, Observable} from 'rxjs';\n\nimport {getLogger} from 'log4js';\nconst logger = getLogger('nuclide-flow-rpc');\n\nimport {track} from '../../nuclide-analytics';\n\nimport {runCommandDetailed, spawn} from 'nuclide-commons/process';\nimport {sleep} from 'nuclide-commons/promise';\nimport {niceSafeSpawn} from 'nuclide-commons/nice';\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\n\nimport {getStopFlowOnExit} from './FlowHelpers';\nimport {getConfig} from './config';\nimport {ServerStatus} from './FlowConstants';\nimport {FlowIDEConnection} from './FlowIDEConnection';\nimport {FlowIDEConnectionWatcher} from './FlowIDEConnectionWatcher';\nimport {FlowVersion} from './FlowVersion';\n\nimport type {FileCache} from '../../nuclide-open-files-rpc';\n\ntype FlowExecResult = {\n  stdout: string,\n  stderr: string,\n  exitCode: ?number,\n};\n\n// Names modeled after https://github.com/facebook/flow/blob/master/src/common/flowExitStatus.ml\nexport const FLOW_RETURN_CODES = {\n  ok: 0,\n  serverInitializing: 1,\n  typeError: 2,\n  noServerRunning: 6,\n  // This means that the server exists, but it is not responding, typically because it is busy doing\n  // other work.\n  outOfRetries: 7,\n  buildIdMismatch: 9,\n  unexpectedArgument: 64,\n};\n\nconst SERVER_READY_TIMEOUT_MS = 60 * 1000;\n\nconst EXEC_FLOW_RETRIES = 5;\n\nconst NO_RETRY_ARGS = [\n  '--retry-if-init',\n  'false',\n  '--retries',\n  '0',\n  '--no-auto-start',\n];\n\nconst TEMP_SERVER_STATES: Array<ServerStatusType> = [\n  ServerStatus.NOT_RUNNING,\n  ServerStatus.BUSY,\n  ServerStatus.INIT,\n];\n\nexport class FlowProcess {\n  // If we had to start a Flow server, store the process here so we can kill it when we shut down.\n  _startedServer: ?child_process$ChildProcess;\n  // The current state of the Flow server in this directory\n  _serverStatus: BehaviorSubject<ServerStatusType>;\n  // The path to the directory where the .flowconfig is -- i.e. the root of the Flow project.\n  _root: string;\n  _execInfoContainer: FlowExecInfoContainer;\n  _version: FlowVersion;\n\n  _ideConnections: Observable<?FlowIDEConnection>;\n\n  // If someone subscribes to _ideConnections, we will also publish them here. But subscribing to\n  // this does not actually cause a connection to be created or maintained.\n  _optionalIDEConnections: BehaviorSubject<?FlowIDEConnection>;\n\n  _isDisposed: BehaviorSubject<boolean>;\n  _subscriptions: UniversalDisposable;\n\n  _fileCache: FileCache;\n\n  constructor(\n    root: string,\n    execInfoContainer: FlowExecInfoContainer,\n    fileCache: FileCache,\n  ) {\n    this._subscriptions = new UniversalDisposable();\n    this._execInfoContainer = execInfoContainer;\n    this._serverStatus = new BehaviorSubject(ServerStatus.UNKNOWN);\n    this._root = root;\n    this._isDisposed = new BehaviorSubject(false);\n    this._fileCache = fileCache;\n\n    this._optionalIDEConnections = new BehaviorSubject(null);\n    this._ideConnections = this._createIDEConnectionStream();\n\n    this._serverStatus.subscribe(status => {\n      logger.info(`[${status}]: Flow server in ${this._root}`);\n    });\n\n    this._serverStatus\n      .filter(x => x === ServerStatus.NOT_RUNNING)\n      .subscribe(() => {\n        this._startFlowServer();\n      });\n\n    this._serverStatus\n      .scan(\n        ({previousState}, nextState) => {\n          // We should start pinging if we move into a temp state\n          const shouldStartPinging =\n            !TEMP_SERVER_STATES.includes(previousState) &&\n            TEMP_SERVER_STATES.includes(nextState);\n          return {\n            shouldStartPinging,\n            previousState: nextState,\n          };\n        },\n        {shouldStartPinging: false, previousState: ServerStatus.UNKNOWN},\n      )\n      .filter(({shouldStartPinging}) => shouldStartPinging)\n      .subscribe(() => {\n        this._pingServer();\n      });\n\n    this._serverStatus\n      .filter(status => status === ServerStatus.FAILED)\n      .subscribe(() => {\n        track('flow-server-failed');\n      });\n\n    this._version = new FlowVersion(async () => {\n      const execInfo = await execInfoContainer.getFlowExecInfo(root);\n      if (!execInfo) {\n        return null;\n      }\n      return execInfo.flowVersion;\n    });\n    this._serverStatus\n      .filter(state => state === 'not running')\n      .subscribe(() => this._version.invalidateVersion());\n  }\n\n  dispose(): void {\n    this._serverStatus.complete();\n    this._isDisposed.next(true);\n    if (this._startedServer && getStopFlowOnExit()) {\n      // The default, SIGTERM, does not reliably kill the flow servers.\n      this._startedServer.kill('SIGKILL');\n    }\n    this._subscriptions.dispose();\n  }\n\n  getVersion(): FlowVersion {\n    return this._version;\n  }\n\n  /**\n   * If the Flow server fails we will not try to restart it again automatically. Calling this\n   * method lets us exit that state and retry.\n   */\n  allowServerRestart(): void {\n    if (this._serverStatus.getValue() === ServerStatus.FAILED) {\n      // We intentionally do not use _setServerStatus because leaving the FAILED state is a\n      // special-case that _setServerStatus does not allow.\n      this._serverStatus.next(ServerStatus.UNKNOWN);\n    }\n  }\n\n  getServerStatusUpdates(): Observable<ServerStatusType> {\n    return this._serverStatus.asObservable();\n  }\n\n  // It is possible for an IDE connection to die. If there are subscribers to this Observable, it\n  // will be automatically restarted and the new one will be sent.\n  //\n  // If the connection dies, `null` will be sent while the next one is being established.\n  getIDEConnections(): Observable<?FlowIDEConnection> {\n    return this._ideConnections;\n  }\n\n  // This will not cause an IDE connection to be established or maintained, and the return value is\n  // not safe to store. If there happens to be an IDE connection it will be returned.\n  getCurrentIDEConnection(): ?FlowIDEConnection {\n    return this._optionalIDEConnections.getValue();\n  }\n\n  _createIDEConnectionStream(): Observable<?FlowIDEConnection> {\n    this._subscriptions.add(\n      this._optionalIDEConnections\n        .filter(conn => conn != null)\n        .switchMap(conn => {\n          invariant(conn != null);\n          return conn.observeRecheckBookends();\n        })\n        .subscribe(bookend => {\n          if (bookend.kind === 'start-recheck') {\n            this._setServerStatus(ServerStatus.BUSY);\n          } else {\n            this._setServerStatus(ServerStatus.READY);\n          }\n        }),\n    );\n\n    const isFailed: Observable<boolean> = this._serverStatus\n      .map(x => x === ServerStatus.FAILED)\n      .distinctUntilChanged();\n    // When we move from failed to non-failed that means we have been explicitly asked to retry\n    // after a Flow server crash. Odds are good that the IDE connection has timed out or is\n    // otherwise unhealthy. So, when we transition from failed to non-failed we should also start\n    // all IDE connection logic anew.\n    const shouldStart: Observable<void> = isFailed\n      .filter(failed => !failed)\n      .mapTo(undefined);\n    return (\n      shouldStart\n        .switchMap(() => this._createSingleIDEConnectionStream())\n        .takeUntil(this._isDisposed.filter(x => x))\n        .concat(Observable.of(null))\n        // This is so we can passively observe IDE connections if somebody happens to be using one. We\n        // want to use it to more quickly update the Flow server status, but it's not crucial to\n        // correctness so we only want to do this if somebody is using the IDE connections anyway.\n        // Don't pass the Subject as an Observer since then it will complete if a client unsubscribes.\n        .do(\n          conn => this._optionalIDEConnections.next(conn),\n          () => {\n            // If we get an error, set the current ide connection to null\n            this._optionalIDEConnections.next(null);\n          },\n          () => {\n            // If we get a completion (happens when the downstream client unsubscribes), set the current ide connection to null.\n            this._optionalIDEConnections.next(null);\n          },\n        )\n        // multicast and store the current connection and immediately deliver it to new subscribers\n        .publishReplay(1)\n        .refCount()\n    );\n  }\n\n  _createSingleIDEConnectionStream(): Observable<?FlowIDEConnection> {\n    logger.info('Creating Flow IDE connection stream');\n    let connectionWatcher: ?FlowIDEConnectionWatcher = null;\n    return Observable.fromEventPattern(\n      // Called when the observable is subscribed to\n      handler => {\n        logger.info('Got a subscriber for the Flow IDE connection stream');\n        invariant(connectionWatcher == null);\n        connectionWatcher = new FlowIDEConnectionWatcher(\n          this._tryCreateIDEProcess(),\n          this._fileCache,\n          handler,\n        );\n        connectionWatcher.start();\n      },\n      // Called when the observable is unsubscribed from\n      () => {\n        logger.info(\n          'No more IDE connection stream subscribers -- shutting down connection watcher',\n        );\n        invariant(connectionWatcher != null);\n        connectionWatcher.dispose();\n        connectionWatcher = null;\n      },\n    );\n  }\n\n  _tryCreateIDEProcess(): Observable<?child_process$ChildProcess> {\n    return Observable.defer(() => this._serverIsReady())\n      .switchMap(serverIsReady => {\n        if (!serverIsReady) {\n          return Observable.of(null);\n        }\n        return this.getVersion()\n          .satisfies('>=0.66.0')\n          .then(supportsFriendlyStatusError => {\n            const jsonFlag = supportsFriendlyStatusError\n              ? ['--json-version', '2']\n              : [];\n            return getAllExecInfo(\n              [\n                'ide',\n                '--protocol',\n                'very-unstable',\n                ...jsonFlag,\n                ...NO_RETRY_ARGS,\n              ],\n              this._root,\n              this._execInfoContainer,\n            );\n          });\n      })\n      .switchMap(allExecInfo => {\n        if (allExecInfo == null) {\n          return Observable.of(null);\n        }\n\n        return spawn(\n          allExecInfo.pathToFlow,\n          allExecInfo.args,\n          allExecInfo.options,\n        ).do(proc => {\n          proc.once('exit', (code: ?number, signal: ?string) => {\n            // If it crashes we will get `null` or `undefined`, but that doesn't actually mean\n            // that Flow is not installed.\n            if (code != null) {\n              this._updateServerStatus(code);\n            }\n          });\n        });\n      });\n  }\n\n  /**\n   * Returns null if Flow cannot be found.\n   */\n  async execFlow(\n    args: Array<any>,\n    options: Object,\n    waitForServer?: boolean = false,\n    suppressErrors?: boolean = false,\n  ): Promise<?FlowExecResult> {\n    const maxRetries = waitForServer ? EXEC_FLOW_RETRIES : 0;\n    if (this._serverStatus.getValue() === ServerStatus.FAILED) {\n      return null;\n    }\n    for (let i = 0; ; i++) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        const result = await this._rawExecFlow(args, options);\n        return result;\n      } catch (e) {\n        const couldRetry =\n          [\n            ServerStatus.NOT_RUNNING,\n            ServerStatus.INIT,\n            ServerStatus.BUSY,\n          ].indexOf(this._serverStatus.getValue()) !== -1;\n        if (i < maxRetries && couldRetry) {\n          // eslint-disable-next-line no-await-in-loop\n          await this._serverIsReady();\n          // Then try again.\n        } else {\n          // If it couldn't retry, it means there was a legitimate error. If it could retry, we\n          // don't want to log because it just means the server is busy and we don't want to wait.\n          if (!couldRetry && !suppressErrors) {\n            // not sure what happened, but we'll let the caller deal with it\n            logger.error(\n              `Flow failed: flow ${args.join(' ')}. Error: ${JSON.stringify(\n                e,\n              )}`,\n            );\n          }\n          throw e;\n        }\n        // try again\n      }\n    }\n  }\n\n  /** Starts a Flow server in the current root */\n  async _startFlowServer(): Promise<void> {\n    // If the server is restarting because of a change in the version specified in the .flowconfig,\n    // then it's important not to use a stale path to start it, since we could have cached the path\n    // to a different version. In that case, starting the server will fail.\n    const flowExecInfo = await this._execInfoContainer.reallyGetFlowExecInfo(\n      this._root,\n    );\n    if (flowExecInfo == null) {\n      // This should not happen in normal use. If Flow is not installed we should have caught it by\n      // now.\n      logger.error(`Could not find Flow to start server in ${this._root}`);\n      this._setServerStatus(ServerStatus.NOT_INSTALLED);\n      return;\n    }\n    const lazy = [];\n    if (getConfig('lazyServer')) {\n      lazy.push('--lazy');\n    }\n    if (getConfig('ideLazyMode')) {\n      lazy.push('--lazy-mode', 'ide');\n    }\n    // `flow server` will start a server in the foreground. runCommand/runCommandDetailed\n    // will not resolve the promise until the process exits, which in this\n    // case is never. We need to use spawn directly to get access to the\n    // ChildProcess object.\n    // eslint-disable-next-line no-await-in-loop\n    const serverProcess = await niceSafeSpawn(\n      flowExecInfo.pathToFlow,\n      [\n        'server',\n        ...lazy,\n        '--from',\n        'nuclide',\n        '--max-workers',\n        this._getMaxWorkers().toString(),\n        this._root,\n      ],\n      flowExecInfo.execOptions,\n    );\n    const logIt = data => {\n      const pid = serverProcess.pid;\n      logger.debug(`flow server (${pid}): ${data}`);\n    };\n    serverProcess.stdout.on('data', logIt);\n    serverProcess.stderr.on('data', logIt);\n    serverProcess.on('exit', (code, signal) => {\n      // We only want to blacklist this root if the Flow processes\n      // actually failed, rather than being killed manually. It seems that\n      // if they are killed, the code is null and the signal is 'SIGTERM'.\n      // In the Flow crashes I have observed, the code is 2 and the signal\n      // is null. So, let's blacklist conservatively for now and we can\n      // add cases later if we observe Flow crashes that do not fit this\n      // pattern.\n      // eslint-disable-next-line eqeqeq\n      if (code === 2 && signal === null) {\n        logger.error('Flow server unexpectedly exited', this._root);\n        this._setServerStatus(ServerStatus.FAILED);\n      }\n    });\n    this._startedServer = serverProcess;\n  }\n\n  /** Execute Flow with the given arguments */\n  async _rawExecFlow(\n    args_: Array<any>,\n    options?: Object = {},\n  ): Promise<?FlowExecResult> {\n    let args = args_;\n    args = [...args, ...NO_RETRY_ARGS];\n    try {\n      const result = await FlowProcess.execFlowClient(\n        args,\n        this._root,\n        this._execInfoContainer,\n        options,\n      );\n      this._updateServerStatus(result != null ? result.exitCode : null);\n      return result;\n    } catch (e) {\n      this._updateServerStatus(e != null ? e.exitCode : null);\n      if (e.exitCode === FLOW_RETURN_CODES.typeError) {\n        return e;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  _updateServerStatus(exitCode: ?number): void {\n    let status;\n    if (exitCode == null) {\n      status = ServerStatus.NOT_INSTALLED;\n    } else {\n      switch (exitCode) {\n        case FLOW_RETURN_CODES.ok:\n        // falls through\n        case FLOW_RETURN_CODES.typeError:\n          status = ServerStatus.READY;\n          break;\n        case FLOW_RETURN_CODES.serverInitializing:\n          status = ServerStatus.INIT;\n          break;\n        case FLOW_RETURN_CODES.noServerRunning:\n          status = ServerStatus.NOT_RUNNING;\n          break;\n        case FLOW_RETURN_CODES.outOfRetries:\n          status = ServerStatus.BUSY;\n          break;\n        case FLOW_RETURN_CODES.buildIdMismatch:\n          // If the version doesn't match, the server is automatically killed and the client\n          // returns 9.\n          logger.info(\n            'Killed flow server with incorrect version in',\n            this._root,\n          );\n          status = ServerStatus.NOT_RUNNING;\n          break;\n        case FLOW_RETURN_CODES.unexpectedArgument:\n          // If we issued an unexpected argument we have learned nothing about the state of the Flow\n          // server. So, don't update.\n          return;\n        default:\n          logger.error(`Unknown return code from Flow: ${String(exitCode)}`);\n          status = ServerStatus.UNKNOWN;\n      }\n    }\n    this._setServerStatus(status);\n  }\n\n  _setServerStatus(status: ServerStatusType): void {\n    const currentStatus = this._serverStatus.getValue();\n    if (\n      // Avoid duplicate updates\n      status !== currentStatus &&\n      // Avoid moving the status away from FAILED, to let any existing  work die out when the\n      // server fails.\n      currentStatus !== ServerStatus.FAILED\n    ) {\n      this._serverStatus.next(status);\n    }\n    if (this._isDisposed.getValue()) {\n      logger.error('Attempted to update server status after disposal');\n    }\n  }\n\n  /** Ping the server until it reaches a steady state */\n  async _pingServer(): Promise<void> {\n    let hasReachedSteadyState = false;\n    this._serverStatus\n      .filter(state => !TEMP_SERVER_STATES.includes(state))\n      .take(1)\n      .subscribe(() => {\n        hasReachedSteadyState = true;\n      });\n    while (!hasReachedSteadyState && !this._isDisposed.getValue()) {\n      // eslint-disable-next-line no-await-in-loop\n      await this._pingServerOnce();\n      // Wait 1 second\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(1000);\n    }\n  }\n\n  _pingServerOnce(): Promise<void> {\n    return this._rawExecFlow(['status'])\n      .catch(() => {})\n      .then(() => {});\n  }\n\n  /**\n   * Resolves when the server is ready or the request times out, as indicated by the result of the\n   * returned Promise.\n   */\n  _serverIsReady(): Promise<boolean> {\n    // If the server state is unknown, nobody has tried to do anything flow-related yet. However,\n    // the call to _serverIsReady() implies that somebody wants to. So, kick off a Flow server ping\n    // which will learn the state of the Flow server and start it up if needed.\n    if (this._serverStatus.getValue() === ServerStatus.UNKNOWN) {\n      this._pingServerOnce();\n    }\n    return (\n      this._serverStatus\n        .filter(x => x === ServerStatus.READY)\n        .map(() => true)\n        .race(Observable.of(false).delay(SERVER_READY_TIMEOUT_MS))\n        // If the stream is completed timeout will not return its default value and we will see an\n        // EmptyError. So, provide a defaultValue here so the promise resolves.\n        .first(null, null, false)\n        .toPromise()\n    );\n  }\n\n  _getMaxWorkers(): number {\n    return Math.max(os.cpus().length - 2, 1);\n  }\n\n  /**\n   * This should be used to execute Flow commands that do not rely on a Flow server. So, they do not\n   * need to be associated with a FlowProcess instance and they may be executed from any working\n   * directory.\n   *\n   * Note that using this method means that you get no guarantee that the Flow version specified in\n   * any given .flowconfig is the one that will be executed here, because it has no association with\n   * any given root. If you need this property, create an instance with the appropriate root and use\n   * execFlow.\n   */\n  static async execFlowClient(\n    args: Array<any>,\n    root: string | null,\n    execInfoContainer: FlowExecInfoContainer,\n    options: Object = {},\n  ): Promise<?FlowExecResult> {\n    const allExecInfo = await getAllExecInfo(\n      args,\n      root,\n      execInfoContainer,\n      options,\n    );\n    if (allExecInfo == null) {\n      return null;\n    }\n\n    // TODO: bubble up the exit code via return value instead of the error\n    return runCommandDetailed(\n      allExecInfo.pathToFlow,\n      allExecInfo.args,\n      allExecInfo.options,\n    ).toPromise();\n  }\n}\n\ntype AllExecInfo = {\n  args: Array<any>,\n  options: Object,\n  pathToFlow: string,\n};\n\nasync function getAllExecInfo(\n  args: Array<any>,\n  root: string | null,\n  execInfoContainer: FlowExecInfoContainer,\n  options: Object = {},\n): Promise<?AllExecInfo> {\n  const execInfo = await execInfoContainer.getFlowExecInfo(root);\n  if (execInfo == null) {\n    return null;\n  }\n  return {\n    args: [...args, '--from', 'nuclide'],\n    options: {\n      ...execInfo.execOptions,\n      ...options,\n    },\n    pathToFlow: execInfo.pathToFlow,\n  };\n}\n"]}