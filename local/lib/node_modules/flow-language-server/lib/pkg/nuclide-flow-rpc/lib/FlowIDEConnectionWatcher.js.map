{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/FlowIDEConnectionWatcher.js"],"names":["defaultIDEConnectionFactory","proc","fileCache","IDE_CONNECTION_MAX_WAIT_MS","IDE_CONNECTION_MIN_INTERVAL_MS","IDE_CONNECTION_HEALTHY_THRESHOLD_MS","MAX_UNHEALTHY_CONNECTIONS","FlowIDEConnectionWatcher","constructor","processFactory","ideConnectionCallback","ideConnectionFactory","_processFactory","_fileCache","_ideConnectionFactory","_ideConnectionCallback","_currentIDEConnection","_currentIDEConnectionSubscription","_consecutiveUnhealthyConnections","_isDisposed","_isStarted","start","_makeIDEConnection","Promise","resolve","info","endTimeMS","_getTimeMS","attemptStartTime","processStream","publish","processPromise","take","toPromise","connect","kill","attemptEndTime","attemptWallTime","additionalWaitTime","_sleep","error","connectionStartTime","ideConnection","onWillDispose","connectionAliveTime","Date","now","ms","dispose"],"mappings":"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","file":"FlowIDEConnectionWatcher.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport {FlowIDEConnection} from './FlowIDEConnection';\n\nimport {sleep} from 'nuclide-commons/promise';\nimport {getLogger} from 'log4js';\nimport {Observable} from 'rxjs';\n\nimport type {FileCache} from '../../nuclide-open-files-rpc';\n\nconst defaultIDEConnectionFactory = (proc, fileCache) =>\n  new FlowIDEConnection(proc, fileCache);\n\n// ESLint thinks the comment at the end is whitespace and warns. Worse, the autofix removes the\n// entire comment as well as the whitespace.\n// eslint-disable-next-line semi-spacing\nconst IDE_CONNECTION_MAX_WAIT_MS =\n  20 /* min */ * 60 /* s/min */ * 1000 /* ms/s */;\n\nconst IDE_CONNECTION_MIN_INTERVAL_MS = 1000;\n\n// If a connection lives shorter than this, it is considered unhealthy (it probably crashed\n// immediately for whatever reason)\nconst IDE_CONNECTION_HEALTHY_THRESHOLD_MS = 10 * 1000;\n\n// If we get this many unhealthy connections in a row, give up.\nconst MAX_UNHEALTHY_CONNECTIONS = 20;\n\ntype IdeConnectionFactory = (\n  child_process$ChildProcess,\n  FileCache,\n) => FlowIDEConnection;\n\n// For the lifetime of this class instance, keep a FlowIDEConnection alive, assuming we do not have\n// too many failures in a row.\nexport class FlowIDEConnectionWatcher {\n  _processFactory: Observable<?child_process$ChildProcess>;\n  _ideConnectionCallback: (?FlowIDEConnection) => mixed;\n  _ideConnectionFactory: (\n    child_process$ChildProcess,\n    FileCache,\n  ) => FlowIDEConnection;\n\n  _currentIDEConnection: ?FlowIDEConnection;\n  _currentIDEConnectionSubscription: ?IDisposable;\n  _consecutiveUnhealthyConnections: number;\n\n  _fileCache: FileCache;\n\n  _isStarted: boolean;\n  _isDisposed: boolean;\n\n  constructor(\n    processFactory: Observable<?child_process$ChildProcess>,\n    fileCache: FileCache,\n    ideConnectionCallback: (?FlowIDEConnection) => mixed,\n    // Can be injected for testing purposes\n    ideConnectionFactory: IdeConnectionFactory = defaultIDEConnectionFactory,\n  ) {\n    this._processFactory = processFactory;\n    this._fileCache = fileCache;\n    this._ideConnectionFactory = ideConnectionFactory;\n    this._ideConnectionCallback = ideConnectionCallback;\n\n    this._currentIDEConnection = null;\n    this._currentIDEConnectionSubscription = null;\n    this._consecutiveUnhealthyConnections = 0;\n\n    this._isDisposed = false;\n    this._isStarted = false;\n  }\n\n  // Returns a promise which resolves when the first connection has been established, or we give up.\n  start(): Promise<void> {\n    if (!this._isStarted) {\n      this._isStarted = true;\n      return this._makeIDEConnection();\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  async _makeIDEConnection(): Promise<void> {\n    getLogger('nuclide-flow-rpc').info('Attempting to start IDE connection...');\n    let proc = null;\n    const endTimeMS = this._getTimeMS() + IDE_CONNECTION_MAX_WAIT_MS;\n    while (true) {\n      const attemptStartTime = this._getTimeMS();\n\n      // Start the process. Eventually we should cancel by unsubscribing, but for now we'll just\n      // convert to an uncancelable promise. We need to use `connect()` because otherwise, `take(1)`\n      // would complete the stream and kill the process as soon as we got it.\n      const processStream = this._processFactory.publish();\n      const processPromise = processStream.take(1).toPromise();\n      processStream.connect();\n\n      // eslint-disable-next-line no-await-in-loop\n      proc = await processPromise;\n      // dispose() could have been called while we were waiting for the above promise to resolve.\n      if (this._isDisposed) {\n        if (proc != null) {\n          proc.kill();\n        }\n        return;\n      }\n      const attemptEndTime = this._getTimeMS();\n      if (proc != null || attemptEndTime > endTimeMS) {\n        break;\n      } else {\n        getLogger('nuclide-flow-rpc').info(\n          'Failed to start Flow IDE connection... retrying',\n        );\n        const attemptWallTime = attemptEndTime - attemptStartTime;\n        const additionalWaitTime =\n          IDE_CONNECTION_MIN_INTERVAL_MS - attemptWallTime;\n        if (additionalWaitTime > 0) {\n          getLogger('nuclide-flow-rpc').info(\n            `Waiting an additional ${additionalWaitTime} ms before retrying`,\n          );\n          // eslint-disable-next-line no-await-in-loop\n          await this._sleep(additionalWaitTime);\n        }\n      }\n    }\n    if (proc == null) {\n      getLogger('nuclide-flow-rpc').error(\n        'Failed to start Flow IDE connection too many times... giving up',\n      );\n      return;\n    }\n    const connectionStartTime = this._getTimeMS();\n    const ideConnection = this._ideConnectionFactory(proc, this._fileCache);\n    this._ideConnectionCallback(ideConnection);\n    this._currentIDEConnectionSubscription = ideConnection.onWillDispose(() => {\n      this._ideConnectionCallback(null);\n      const connectionAliveTime = this._getTimeMS() - connectionStartTime;\n      if (connectionAliveTime < IDE_CONNECTION_HEALTHY_THRESHOLD_MS) {\n        this._consecutiveUnhealthyConnections++;\n        if (\n          this._consecutiveUnhealthyConnections >= MAX_UNHEALTHY_CONNECTIONS\n        ) {\n          getLogger('nuclide-flow-rpc').error(\n            'Too many consecutive unhealthy Flow IDE connections... giving up',\n          );\n          return;\n        }\n      } else {\n        this._consecutiveUnhealthyConnections = 0;\n      }\n      this._makeIDEConnection();\n    });\n\n    this._currentIDEConnection = ideConnection;\n  }\n\n  // Split this out just so it's easy to mock\n  _getTimeMS(): number {\n    return Date.now();\n  }\n\n  // Split this out just so it's easy to mock\n  _sleep(ms: number): Promise<void> {\n    return sleep(ms);\n  }\n\n  dispose(): void {\n    if (!this._isDisposed) {\n      this._isDisposed = true;\n      if (this._currentIDEConnectionSubscription != null) {\n        this._currentIDEConnectionSubscription.dispose();\n      }\n      if (this._currentIDEConnection != null) {\n        this._currentIDEConnection.dispose();\n      }\n    }\n  }\n}\n"]}