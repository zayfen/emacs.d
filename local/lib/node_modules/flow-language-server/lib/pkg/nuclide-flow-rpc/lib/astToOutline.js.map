{"version":3,"sources":["../../../../src/pkg/nuclide-flow-rpc/lib/astToOutline.js"],"names":["astToOutline","ast","outlineTrees","itemsToTrees","body","items","map","itemToTree","item","extent","getExtent","type","functionOutline","id","name","params","tokenizedText","representativeName","undefined","push","kind","children","paramTokens","value","declarationsTokenizedText","key","exportDeclaration","Boolean","default","topLevelExpressionOutline","typeAliasOutline","variableDeclarationOutline","declareClassOutline","declareFunctionOutline","declareModuleOutline","declareVariableOutline","isDefault","tree","declaration","declarationReducer","textElements","p","index","declarations","properties","obj","elements","left","argument","Error","length","reduce","startPosition","loc","start","line","column","endPosition","end","typeAliasExpression","expressionStatement","expression","specOutline","moduleExportsOutline","assignmentStatement","isModuleExports","right","moduleExportsPropertyOutline","object","property","propName","shorthand","describeOnly","functionName","getFunctionName","callee","isDescribe","isIt","description","getStringLiteralValue","arguments","specBody","getFunctionBody","filter","literal","fn","variableDeclaratorOutline","declarator","init","declareClassPropertyOutline","typeAnnotation"],"mappings":";;;;;;kQAAA;;;;;;;;;;;;QAqCgBA,Y,GAAAA,Y;;AAvBhB;;AAEA;;AAGA;;AAWA;;;;;;AAOO,SAASA,YAAT,CAAsBC,GAAtB,EAAyC;AAC9C,SAAO;AACLC,kBAAcC,aAAaF,IAAIG,IAAjB;AADT,GAAP;AAGD;;AAED,SAASD,YAAT,CAAsBE,KAAtB,EAA6D;AAC3D,SAAO,8BAAaA,MAAMC,GAAN,CAAUC,UAAV,CAAb,CAAP;AACD;;AAED,SAASA,UAAT,CAAoBC,IAApB,EAA6C;AAC3C,MAAIA,QAAQ,IAAZ,EAAkB;AAChB,WAAO,IAAP;AACD;AACD,QAAMC,SAASC,UAAUF,IAAV,CAAf;AACA,UAAQA,KAAKG,IAAb;AACE,SAAK,qBAAL;AACA,SAAK,yBAAL;AACE,aAAOC,gBACLJ,KAAKK,EAAL,IAAW,IAAX,GAAkBL,KAAKK,EAAL,CAAQC,IAA1B,GAAiC,EAD5B,EAELN,KAAKO,MAFA,EAGLN,MAHK,CAAP;AAKF,SAAK,kBAAL;AACA,SAAK,iBAAL;AACE,YAAMO,gBAAgB,CAAC,4BAAQ,OAAR,CAAD,CAAtB;AACA,UAAIC,qBAAqBC,SAAzB;AACA,UAAIV,KAAKK,EAAL,IAAW,IAAf,EAAqB;AACnBG,sBAAcG,IAAd,CAAmB,+BAAW,GAAX,CAAnB,EAAoC,8BAAUX,KAAKK,EAAL,CAAQC,IAAlB,CAApC;AACAG,6BAAqBT,KAAKK,EAAL,CAAQC,IAA7B;AACD;AACD;AACEM,cAAM,OADR;AAEEJ,qBAFF;AAGEC,0BAHF;AAIEI,kBAAUlB,aAAaK,KAAKJ,IAAL,CAAUA,IAAvB;AAJZ,SAKKK,MALL;AAOF,SAAK,eAAL;AACE,UAAIa,cAAc,EAAlB;AACA,UAAId,KAAKe,KAAL,IAAcf,KAAKe,KAAL,CAAWZ,IAAX,KAAoB,yBAAtC,EAAiE;AAC/DW,sBAAc,CACZ,0BAAM,GAAN,CADY,EAEZ,GAAGE,0BAA0BhB,KAAKe,KAAL,CAAWR,MAArC,CAFS,EAGZ,0BAAM,GAAN,CAHY,CAAd;AAKD;AACD;AACEK,cAAM,UADR;AAEEJ,uBAAe,CAAC,2BAAOR,KAAKiB,GAAL,CAASX,IAAhB,CAAD,EAAwB,0BAAM,GAAN,CAAxB,EAAoC,GAAGQ,WAAvC,CAFjB;AAGEL,4BAAoBT,KAAKiB,GAAL,CAASX,IAH/B;AAIEO,kBAAU;AAJZ,SAKKZ,MALL;AAOF,SAAK,kBAAL;AACE;AACEW,cAAM,QADR;AAEEJ,uBAAe,CACb,2BAAOR,KAAKiB,GAAL,CAASX,IAAhB,CADa,EAEb,0BAAM,GAAN,CAFa,EAGb,GAAGU,0BAA0BhB,KAAKe,KAAL,CAAWR,MAArC,CAHU,EAIb,0BAAM,GAAN,CAJa,CAFjB;AAQEE,4BAAoBT,KAAKiB,GAAL,CAASX,IAR/B;AASEO,kBAAU;AATZ,SAUKZ,MAVL;AAYF,SAAK,mBAAL;AACA,SAAK,wBAAL;AACA,SAAK,0BAAL;AACE,aAAOiB,kBAAkBlB,IAAlB,EAAwBC,MAAxB,EAAgCkB,QAAQnB,KAAKoB,OAAb,CAAhC,CAAP;AACF,SAAK,0BAAL;AACE,aAAOF,kBAAkBlB,IAAlB,EAAwBC,MAAxB,EAAgC,IAAhC,CAAP;AACF,SAAK,qBAAL;AACE,aAAOoB,0BAA0BrB,IAA1B,CAAP;AACF,SAAK,WAAL;AACE,aAAOsB,iBAAiBtB,IAAjB,CAAP;AACF,SAAK,qBAAL;AACE,aAAOuB,2BAA2BvB,IAA3B,CAAP;AACF,SAAK,cAAL;AACE,aAAOwB,oBAAoBxB,IAApB,EAA0BC,MAA1B,CAAP;AACF,SAAK,iBAAL;AACE,aAAOwB,uBAAuBzB,IAAvB,EAA6BC,MAA7B,CAAP;AACF,SAAK,eAAL;AACE,aAAOyB,qBAAqB1B,IAArB,EAA2BC,MAA3B,CAAP;AACF,SAAK,iBAAL;AACE,aAAO0B,uBAAuB3B,IAAvB,EAA6BC,MAA7B,CAAP;AACF;AACE,aAAO,IAAP;AAzEJ;AA2ED;;AAED,SAASiB,iBAAT,CACElB,IADF,EAEEC,MAFF,EAGE2B,SAHF,EAIgB;AACd,QAAMC,OAAO9B,WAAWC,KAAK8B,WAAhB,CAAb;AACA,MAAID,QAAQ,IAAZ,EAAkB;AAChB,WAAO,IAAP;AACD;AACD,QAAMrB,gBAAgB,CAAC,4BAAQ,QAAR,CAAD,EAAoB,+BAAW,GAAX,CAApB,CAAtB;AACA,MAAIoB,SAAJ,EAAe;AACbpB,kBAAcG,IAAd,CAAmB,4BAAQ,SAAR,CAAnB,EAAuC,+BAAW,GAAX,CAAvC;AACD;AACD;AACA,wBAAUkB,KAAKrB,aAAL,IAAsB,IAAhC;AACAA,gBAAcG,IAAd,CAAmB,GAAGkB,KAAKrB,aAA3B;AACA;AACEI,UAAMiB,KAAKjB,IADb;AAEEJ,iBAFF;AAGEC,wBAAoBoB,KAAKpB,kBAH3B;AAIEI,cAAUgB,KAAKhB;AAJjB,KAKKZ,MALL;AAOD;;AAED,SAAS8B,kBAAT,CACEC,YADF,EAEEC,CAFF,EAGEC,KAHF,EAIEC,YAJF,EAKiB;AACf,UAAQF,EAAE9B,IAAV;AACE,SAAK,YAAL;AACE6B,mBAAarB,IAAb,CAAkB,0BAAMsB,EAAE3B,IAAR,CAAlB;AACA;AACF,SAAK,eAAL;AACE0B,mBAAarB,IAAb,CAAkB,0BAAM,GAAN,CAAlB;AACAqB,mBAAarB,IAAb,CACE,GAAGK,0BAA0BiB,EAAEG,UAAF,CAAatC,GAAb,CAAiBuC,OAAOA,IAAIpB,GAA5B,CAA1B,CADL;AAGAe,mBAAarB,IAAb,CAAkB,0BAAM,GAAN,CAAlB;AACA;AACF,SAAK,cAAL;AACEqB,mBAAarB,IAAb,CAAkB,0BAAM,GAAN,CAAlB;AACAqB,mBAAarB,IAAb,CAAkB,GAAGK,0BAA0BiB,EAAEK,QAA5B,CAArB;AACAN,mBAAarB,IAAb,CAAkB,0BAAM,GAAN,CAAlB;AACA;AACF,SAAK,mBAAL;AACE,aAAOoB,mBAAmBC,YAAnB,EAAiCC,EAAEM,IAAnC,EAAyCL,KAAzC,EAAgDC,YAAhD,CAAP;AACF,SAAK,aAAL;AACEH,mBAAarB,IAAb,CAAkB,0BAAM,KAAN,CAAlB;AACA,aAAOoB,mBAAmBC,YAAnB,EAAiCC,EAAEO,QAAnC,EAA6CN,KAA7C,EAAoDC,YAApD,CAAP;AACF,SAAK,mBAAL;AACE;AACA,UAAIF,EAAE3B,IAAN,EAAY;AACV0B,qBAAarB,IAAb,CAAkB,0BAAMsB,EAAE3B,IAAF,CAAOA,IAAb,CAAlB;AACD;AACD;AACF;AACE,YAAM,IAAImC,KAAJ,CAAW,wCAAuCR,EAAE9B,IAAK,EAAzD,CAAN;AA5BJ;AA8BA,MAAI+B,QAAQC,aAAaO,MAAb,GAAsB,CAAlC,EAAqC;AACnCV,iBAAarB,IAAb,CAAkB,0BAAM,GAAN,CAAlB;AACAqB,iBAAarB,IAAb,CAAkB,+BAAW,GAAX,CAAlB;AACD;AACD,SAAOqB,YAAP;AACD;;AAED,SAAShB,yBAAT,CAAmCmB,YAAnC,EAA4E;AAC1E,SAAOA,aAAaQ,MAAb,CAAoBZ,kBAApB,EAAwC,EAAxC,CAAP;AACD;;AAED,SAAS7B,SAAT,CAAmBF,IAAnB,EAAsC;AACpC,SAAO;AACL4C,mBAAe;AACb;AACA;AACA5C,SAAK6C,GAAL,CAASC,KAAT,CAAeC,IAAf,GAAsB,CAHT,EAIb/C,KAAK6C,GAAL,CAASC,KAAT,CAAeE,MAJF,CADV;AAOLC,iBAAa,4BAAUjD,KAAK6C,GAAL,CAASK,GAAT,CAAaH,IAAb,GAAoB,CAA9B,EAAiC/C,KAAK6C,GAAL,CAASK,GAAT,CAAaF,MAA9C;AAPR,GAAP;AASD;;AAED,SAAS5C,eAAT,CACEE,IADF,EAEEC,MAFF,EAGEN,MAHF,EAIe;AACb;AACEW,UAAM,UADR;AAEEJ,mBAAe,CACb,4BAAQ,UAAR,CADa,EAEb,+BAAW,GAAX,CAFa,EAGb,2BAAOF,IAAP,CAHa,EAIb,0BAAM,GAAN,CAJa,EAKb,GAAGU,0BAA0BT,MAA1B,CALU,EAMb,0BAAM,GAAN,CANa,CAFjB;AAUEE,wBAAoBH,IAVtB;AAWEO,cAAU;AAXZ,KAYKZ,MAZL;AAcD;;AAED,SAASqB,gBAAT,CAA0B6B,mBAA1B,EAAiE;AAC/D,wBAAUA,oBAAoBhD,IAApB,KAA6B,WAAvC;AACA,QAAMG,OAAO6C,oBAAoB9C,EAApB,CAAuBC,IAApC;AACA;AACEM,UAAM,WADR;AAEEJ,mBAAe,CAAC,4BAAQ,MAAR,CAAD,EAAkB,+BAAW,GAAX,CAAlB,EAAmC,yBAAKF,IAAL,CAAnC,CAFjB;AAGEG,wBAAoBH,IAHtB;AAIEO,cAAU;AAJZ,KAKKX,UAAUiD,mBAAV,CALL;AAOD;;AAED,SAAS9B,yBAAT,CAAmC+B,mBAAnC,EAA2E;AACzE,UAAQA,oBAAoBC,UAApB,CAA+BlD,IAAvC;AACE,SAAK,gBAAL;AACE,aAAOmD,YAAYF,mBAAZ,EAAiC,kBAAmB,IAApD,CAAP;AACF,SAAK,sBAAL;AACE,aAAOG,qBAAqBH,oBAAoBC,UAAzC,CAAP;AACF;AACE,aAAO,IAAP;AANJ;AAQD;;AAED,SAASE,oBAAT,CAA8BC,mBAA9B,EAAsE;AACpE,wBAAUA,oBAAoBrD,IAApB,KAA6B,sBAAvC;;AAEA,QAAMoC,OAAOiB,oBAAoBjB,IAAjC;AACA,MAAI,CAACkB,gBAAgBlB,IAAhB,CAAL,EAA4B;AAC1B,WAAO,IAAP;AACD;;AAED,QAAMmB,QAAQF,oBAAoBE,KAAlC;AACA,MAAIA,MAAMvD,IAAN,KAAe,kBAAnB,EAAuC;AACrC,WAAO,IAAP;AACD;AACD,QAAMiC,aAA4BsB,MAAMtB,UAAxC;AACA;AACExB,UAAM,QADR;AAEEJ,mBAAe,CAAC,0BAAM,gBAAN,CAAD,CAFjB;AAGEK,cAAU,8BAAauB,WAAWtC,GAAX,CAAe6D,4BAAf,CAAb;AAHZ,KAIKzD,UAAUsD,mBAAV,CAJL;AAMD;;AAED,SAASC,eAAT,CAAyBlB,IAAzB,EAAgD;AAC9C,SACEA,KAAKpC,IAAL,KAAc,kBAAd,IACAoC,KAAKqB,MAAL,CAAYzD,IAAZ,KAAqB,YADrB,IAEAoC,KAAKqB,MAAL,CAAYtD,IAAZ,KAAqB,QAFrB,IAGAiC,KAAKsB,QAAL,CAAc1D,IAAd,KAAuB,YAHvB,IAIAoC,KAAKsB,QAAL,CAAcvD,IAAd,KAAuB,SALzB;AAOD;;AAED,SAASqD,4BAAT,CAAsCE,QAAtC,EAAmE;AACjE,wBAAUA,SAAS1D,IAAT,KAAkB,UAA5B;AACA,MAAI0D,SAAS5C,GAAT,CAAad,IAAb,KAAsB,YAA1B,EAAwC;AACtC,WAAO,IAAP;AACD;AACD,QAAM2D,WAAWD,SAAS5C,GAAT,CAAaX,IAA9B;;AAEA,MAAIuD,SAASE,SAAb,EAAwB;AACtB;AACA;AACEnD,YAAM,QADR;AAEEJ,qBAAe,CAAC,2BAAOsD,QAAP,CAAD,CAFjB;AAGErD,0BAAoBqD,QAHtB;AAIEjD,gBAAU;AAJZ,OAKKX,UAAU2D,QAAV,CALL;AAOD;;AAED,MACEA,SAAS9C,KAAT,CAAeZ,IAAf,KAAwB,oBAAxB,IACA0D,SAAS9C,KAAT,CAAeZ,IAAf,KAAwB,yBAF1B,EAGE;AACA;AACES,YAAM,QADR;AAEEJ,qBAAe,CACb,2BAAOsD,QAAP,CADa,EAEb,0BAAM,GAAN,CAFa,EAGb,GAAG9C,0BAA0B6C,SAAS9C,KAAT,CAAeR,MAAzC,CAHU,EAIb,0BAAM,GAAN,CAJa,CAFjB;AAQEE,0BAAoBqD,QARtB;AASEjD,gBAAU;AATZ,OAUKX,UAAU2D,QAAV,CAVL;AAYD;;AAED;AACEjD,UAAM,OADR;AAEEJ,mBAAe,CAAC,2BAAOsD,QAAP,CAAD,EAAmB,0BAAM,GAAN,CAAnB,CAFjB;AAGErD,wBAAoBqD,QAHtB;AAIEjD,cAAU;AAJZ,KAKKX,UAAU2D,QAAV,CALL;AAOD;;AAED,SAASP,WAAT,CACEF,mBADF,EAEEY,eAAwB,KAF1B,EAGgB;AACd,QAAMX,aAAaD,oBAAoBC,UAAvC;AACA,MAAIA,WAAWlD,IAAX,KAAoB,gBAAxB,EAA0C;AACxC,WAAO,IAAP;AACD;AACD,QAAM8D,eAAeC,gBAAgBb,WAAWc,MAA3B,CAArB;AACA,MAAIF,gBAAgB,IAApB,EAA0B;AACxB,WAAO,IAAP;AACD;AACD,MAAI,CAACG,WAAWH,YAAX,CAAL,EAA+B;AAC7B,QAAID,gBAAgB,CAACK,KAAKJ,YAAL,CAArB,EAAyC;AACvC,aAAO,IAAP;AACD;AACF;AACD,QAAMK,cAAcC,sBAAsBlB,WAAWmB,SAAX,CAAqB,CAArB,CAAtB,CAApB;AACA,QAAMC,WAAWC,gBAAgBrB,WAAWmB,SAAX,CAAqB,CAArB,CAAhB,CAAjB;AACA,MAAIF,eAAe,IAAf,IAAuBG,YAAY,IAAvC,EAA6C;AAC3C,WAAO,IAAP;AACD;AACD,MAAI5D,QAAJ;AACA,MAAIwD,KAAKJ,YAAL,CAAJ,EAAwB;AACtBpD,eAAW,EAAX;AACD,GAFD,MAEO;AACLA,eAAW,8BACT4D,SACGE,MADH,CACU3E,QAAQA,KAAKG,IAAL,KAAc,qBADhC,EAEGL,GAFH,CAEOE,QAAQsD,YAAYtD,IAAZ,CAFf,CADS,CAAX;AAKD;AACD;AACEY,UAAM,UADR;AAEEJ,mBAAe,CAAC,2BAAOyD,YAAP,CAAD,EAAuB,+BAAW,GAAX,CAAvB,EAAwC,2BAAOK,WAAP,CAAxC,CAFjB;AAGE7D,wBAAoB6D,WAHtB;AAIEzD;AAJF,KAKKX,UAAUkD,mBAAV,CALL;AAOD;;AAED;AACA;AACA,SAASc,eAAT,CAAyBC,MAAzB,EAA+C;AAC7C,UAAQA,OAAOhE,IAAf;AACE,SAAK,YAAL;AACE,aAAOgE,OAAO7D,IAAd;AACF,SAAK,kBAAL;AACE,UACE6D,OAAOP,MAAP,CAAczD,IAAd,KAAuB,YAAvB,IACAgE,OAAON,QAAP,CAAgB1D,IAAhB,KAAyB,YAF3B,EAGE;AACA,eAAO,IAAP;AACD;AACD,aAAQ,GAAEgE,OAAOP,MAAP,CAActD,IAAK,IAAG6D,OAAON,QAAP,CAAgBvD,IAAK,EAArD;AACF;AACE,aAAO,IAAP;AAZJ;AAcD;;AAED,SAAS8D,UAAT,CAAoBH,YAApB,EAAmD;AACjD,UAAQA,YAAR;AACE,SAAK,UAAL;AACA,SAAK,WAAL;AACA,SAAK,WAAL;AACA,SAAK,WAAL;AACA,SAAK,eAAL;AACA,SAAK,eAAL;AACA,SAAK,SAAL;AACA,SAAK,aAAL;AACA,SAAK,WAAL;AACA,SAAK,cAAL;AACA,SAAK,MAAL;AACA,SAAK,iBAAL;AACA,SAAK,WAAL;AACA,SAAK,WAAL;AACA,SAAK,OAAL;AACA,SAAK,YAAL;AACA,SAAK,YAAL;AACA,SAAK,OAAL;AACA,SAAK,kBAAL;AACA,SAAK,YAAL;AACA,SAAK,YAAL;AACE,aAAO,IAAP;AACF;AACE,aAAO,KAAP;AAxBJ;AA0BD;;AAED,SAASI,IAAT,CAAcJ,YAAd,EAA6C;AAC3C,UAAQA,YAAR;AACE,SAAK,IAAL;AACA,SAAK,KAAL;AACA,SAAK,KAAL;AACA,SAAK,KAAL;AACA,SAAK,KAAL;AACA,SAAK,SAAL;AACA,SAAK,SAAL;AACE,aAAO,IAAP;AACF;AACE,aAAO,KAAP;AAVJ;AAYD;;AAED;AACA,SAASM,qBAAT,CAA+BK,OAA/B,EAAuD;AACrD,MAAIA,WAAW,IAAf,EAAqB;AACnB,WAAO,IAAP;AACD;AACD,MAAIA,QAAQzE,IAAR,KAAiB,SAArB,EAAgC;AAC9B,WAAO,IAAP;AACD;AACD,QAAMY,QAAQ6D,QAAQ7D,KAAtB;AACA,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAO,IAAP;AACD;AACD,SAAOA,KAAP;AACD;;AAED,SAAS2D,eAAT,CAAyBG,EAAzB,EAAgD;AAC9C,MAAIA,MAAM,IAAV,EAAgB;AACd,WAAO,IAAP;AACD;AACD,MACEA,GAAG1E,IAAH,KAAY,yBAAZ,IACA0E,GAAG1E,IAAH,KAAY,oBAFd,EAGE;AACA,WAAO,IAAP;AACD;AACD,SAAO0E,GAAGjF,IAAH,CAAQA,IAAf;AACD;;AAED,SAAS2B,0BAAT,CAAoCO,WAApC,EAAoE;AAClE;AACA,SAAOgD,0BACLhD,YAAYK,YAAZ,CAAyB,CAAzB,CADK,EAELL,YAAYlB,IAFP,EAGLV,UAAU4B,WAAV,CAHK,CAAP;AAKD;;AAED,SAASgD,yBAAT,CACEC,UADF,EAEEnE,IAFF,EAGEX,MAHF,EAIgB;AACd,MACE8E,WAAWC,IAAX,IAAmB,IAAnB,KACCD,WAAWC,IAAX,CAAgB7E,IAAhB,KAAyB,oBAAzB,IACC4E,WAAWC,IAAX,CAAgB7E,IAAhB,KAAyB,yBAF3B,CADF,EAIE;AACA,WAAOC,gBAAgB2E,WAAW1E,EAAX,CAAcC,IAA9B,EAAoCyE,WAAWC,IAAX,CAAgBzE,MAApD,EAA4DN,MAA5D,CAAP;AACD;;AAPa,QASPI,EATO,GASD0E,UATC,CASP1E,EATO;;;AAWd,QAAMG,gBAAgB,CACpB,4BAAQI,IAAR,CADoB,EAEpB,+BAAW,GAAX,CAFoB,EAGpB,GAAGI,0BAA0B,CAACX,EAAD,CAA1B,CAHiB,CAAtB;AAKA,QAAMI,qBAAqBJ,GAAGF,IAAH,KAAY,YAAZ,GAA2BE,GAAGC,IAA9B,GAAqCI,SAAhE;AACA;AACEE,UAAMA,SAAS,OAAT,GAAmB,UAAnB,GAAgC,UADxC;AAEEJ,iBAFF;AAGEC,sBAHF;AAIEI,cAAU;AAJZ,KAKKZ,MALL;AAOD;AACD,SAASuB,mBAAT,CAA6BxB,IAA7B,EAAwCC,MAAxC,EAAsE;AACpE,QAAMO,gBAAgB,CAAC,4BAAQ,OAAR,CAAD,CAAtB;AACA,MAAIC,qBAAqBC,SAAzB;AACA,MAAIV,KAAKK,EAAL,IAAW,IAAf,EAAqB;AACnBG,kBAAcG,IAAd,CAAmB,+BAAW,GAAX,CAAnB,EAAoC,8BAAUX,KAAKK,EAAL,CAAQC,IAAlB,CAApC;AACAG,yBAAqBT,KAAKK,EAAL,CAAQC,IAA7B;AACD;AACD,QAAM8B,aAAapC,KAAKJ,IAAL,CAAUwC,UAA7B;AACA;AACExB,UAAM,OADR;AAEEJ,iBAFF;AAGEC,sBAHF;AAIEI,cAAU,8BAAauB,WAAWtC,GAAX,CAAemF,2BAAf,CAAb;AAJZ,KAKKhF,MALL;AAOD;AACD,SAASgF,2BAAT,CAAqCjF,IAArC,EAA8D;AAC5D,MAAIA,KAAKiB,GAAL,IAAY,IAAhB,EAAsB;AACpB,WAAO,IAAP;AACD;AACD,QAAMR,qBAAqBT,KAAKiB,GAAL,CAASX,IAApC;AACA,QAAML,SAASC,UAAUF,IAAV,CAAf;AACA,UAAQA,KAAKe,KAAL,CAAWZ,IAAnB;AACE,SAAK,wBAAL;AACE,aAAOC,gBAAgBK,kBAAhB,EAAoCT,KAAKe,KAAL,CAAWR,MAA/C,EAAuDN,MAAvD,CAAP;AACF,SAAK,sBAAL;AACA,SAAK,uBAAL;AACE;AACEW,cAAM,UADR;AAEEJ,uBAAe,CAAC,2BAAOC,kBAAP,CAAD,CAFjB;AAGEA,0BAHF;AAIEI,kBAAU;AAJZ,SAKKZ,MALL;AAOF;AACE,aAAO,IAAP;AAbJ;AAeD;;AAED,SAASwB,sBAAT,CAAgCzB,IAAhC,EAA2CC,MAA3C,EAAyE;AACvE,QAAMM,SAASP,KAAKK,EAAL,CAAQ6E,cAAR,CAAuBA,cAAvB,CAAsC3E,MAArD;AACA,SAAOH,gBAAgBJ,KAAKK,EAAL,CAAQC,IAAxB,EAA8BC,OAAOT,GAAP,CAAWuC,OAAOA,IAAI/B,IAAtB,CAA9B,EAA2DL,MAA3D,CAAP;AACD;AACD,SAASyB,oBAAT,CAA8B1B,IAA9B,EAAyCC,MAAzC,EAAuE;AACrE,QAAMO,gBAAgB,CAAC,4BAAQ,QAAR,CAAD,CAAtB;AACA,MAAIC,qBAAqBC,SAAzB;AACA,MAAIV,KAAKK,EAAL,IAAW,IAAf,EAAqB;AACnBG,kBAAcG,IAAd,CAAmB,+BAAW,GAAX,CAAnB,EAAoC,8BAAUX,KAAKK,EAAL,CAAQU,KAAlB,CAApC;AACAN,yBAAqBT,KAAKK,EAAL,CAAQU,KAA7B;AACD;AACD;AACEH,UAAM,WADR;AAEEJ,iBAFF;AAGEC,sBAHF;AAIEI,cAAUlB,aAAaK,KAAKJ,IAAL,CAAUA,IAAvB;AAJZ,KAKKK,MALL;AAOD;AACD,SAAS0B,sBAAT,CAAgC3B,IAAhC,EAA2CC,MAA3C,EAAyE;AACvE;AACEW,UAAM,UADR;AAEEJ,mBAAe,CAAC,4BAAQ,KAAR,CAAD,EAAiB,+BAAW,GAAX,CAAjB,EAAkC,2BAAOR,KAAKK,EAAL,CAAQC,IAAf,CAAlC,CAFjB;AAGEG,wBAAoBT,KAAKK,EAAL,CAAQC,IAH9B;AAIEO,cAAU;AAJZ,KAKKZ,MALL;AAOD","file":"astToOutline.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n * @format\n */\n\nimport type {Outline, OutlineTree} from 'atom-ide-ui';\n\nimport {Point} from 'simple-text-buffer';\n\nimport {arrayCompact} from 'nuclide-commons/collection';\n\nimport type {TokenizedText} from 'nuclide-commons/tokenized-text';\nimport {\n  keyword,\n  className,\n  method,\n  param,\n  string,\n  whitespace,\n  plain,\n  type,\n} from 'nuclide-commons/tokenized-text';\n\nimport invariant from 'assert';\n\ntype Extent = {\n  startPosition: atom$Point,\n  endPosition: atom$Point,\n};\n\nexport function astToOutline(ast: any): Outline {\n  return {\n    outlineTrees: itemsToTrees(ast.body),\n  };\n}\n\nfunction itemsToTrees(items: Array<any>): Array<OutlineTree> {\n  return arrayCompact(items.map(itemToTree));\n}\n\nfunction itemToTree(item: any): ?OutlineTree {\n  if (item == null) {\n    return null;\n  }\n  const extent = getExtent(item);\n  switch (item.type) {\n    case 'FunctionDeclaration':\n    case 'ArrowFunctionExpression':\n      return functionOutline(\n        item.id != null ? item.id.name : '',\n        item.params,\n        extent,\n      );\n    case 'ClassDeclaration':\n    case 'ClassExpression':\n      const tokenizedText = [keyword('class')];\n      let representativeName = undefined;\n      if (item.id != null) {\n        tokenizedText.push(whitespace(' '), className(item.id.name));\n        representativeName = item.id.name;\n      }\n      return {\n        kind: 'class',\n        tokenizedText,\n        representativeName,\n        children: itemsToTrees(item.body.body),\n        ...extent,\n      };\n    case 'ClassProperty':\n      let paramTokens = [];\n      if (item.value && item.value.type === 'ArrowFunctionExpression') {\n        paramTokens = [\n          plain('('),\n          ...declarationsTokenizedText(item.value.params),\n          plain(')'),\n        ];\n      }\n      return {\n        kind: 'property',\n        tokenizedText: [method(item.key.name), plain('='), ...paramTokens],\n        representativeName: item.key.name,\n        children: [],\n        ...extent,\n      };\n    case 'MethodDefinition':\n      return {\n        kind: 'method',\n        tokenizedText: [\n          method(item.key.name),\n          plain('('),\n          ...declarationsTokenizedText(item.value.params),\n          plain(')'),\n        ],\n        representativeName: item.key.name,\n        children: [],\n        ...extent,\n      };\n    case 'ExportDeclaration':\n    case 'ExportNamedDeclaration':\n    case 'DeclareExportDeclaration':\n      return exportDeclaration(item, extent, Boolean(item.default));\n    case 'ExportDefaultDeclaration':\n      return exportDeclaration(item, extent, true);\n    case 'ExpressionStatement':\n      return topLevelExpressionOutline(item);\n    case 'TypeAlias':\n      return typeAliasOutline(item);\n    case 'VariableDeclaration':\n      return variableDeclarationOutline(item);\n    case 'DeclareClass':\n      return declareClassOutline(item, extent);\n    case 'DeclareFunction':\n      return declareFunctionOutline(item, extent);\n    case 'DeclareModule':\n      return declareModuleOutline(item, extent);\n    case 'DeclareVariable':\n      return declareVariableOutline(item, extent);\n    default:\n      return null;\n  }\n}\n\nfunction exportDeclaration(\n  item: any,\n  extent: Extent,\n  isDefault: boolean,\n): ?OutlineTree {\n  const tree = itemToTree(item.declaration);\n  if (tree == null) {\n    return null;\n  }\n  const tokenizedText = [keyword('export'), whitespace(' ')];\n  if (isDefault) {\n    tokenizedText.push(keyword('default'), whitespace(' '));\n  }\n  // Flow always has tokenizedText\n  invariant(tree.tokenizedText != null);\n  tokenizedText.push(...tree.tokenizedText);\n  return {\n    kind: tree.kind,\n    tokenizedText,\n    representativeName: tree.representativeName,\n    children: tree.children,\n    ...extent,\n  };\n}\n\nfunction declarationReducer(\n  textElements: TokenizedText,\n  p: any,\n  index: number,\n  declarations: Array<any>,\n): TokenizedText {\n  switch (p.type) {\n    case 'Identifier':\n      textElements.push(param(p.name));\n      break;\n    case 'ObjectPattern':\n      textElements.push(plain('{'));\n      textElements.push(\n        ...declarationsTokenizedText(p.properties.map(obj => obj.key)),\n      );\n      textElements.push(plain('}'));\n      break;\n    case 'ArrayPattern':\n      textElements.push(plain('['));\n      textElements.push(...declarationsTokenizedText(p.elements));\n      textElements.push(plain(']'));\n      break;\n    case 'AssignmentPattern':\n      return declarationReducer(textElements, p.left, index, declarations);\n    case 'RestElement':\n      textElements.push(plain('...'));\n      return declarationReducer(textElements, p.argument, index, declarations);\n    case 'FunctionTypeParam':\n      // Very similar to the Identifier case, but with different obj structure\n      if (p.name) {\n        textElements.push(param(p.name.name));\n      }\n      break;\n    default:\n      throw new Error(`encountered unexpected argument type ${p.type}`);\n  }\n  if (index < declarations.length - 1) {\n    textElements.push(plain(','));\n    textElements.push(whitespace(' '));\n  }\n  return textElements;\n}\n\nfunction declarationsTokenizedText(declarations: Array<any>): TokenizedText {\n  return declarations.reduce(declarationReducer, []);\n}\n\nfunction getExtent(item: any): Extent {\n  return {\n    startPosition: new Point(\n      // It definitely makes sense that the lines we get are 1-based and the columns are\n      // 0-based... convert to 0-based all around.\n      item.loc.start.line - 1,\n      item.loc.start.column,\n    ),\n    endPosition: new Point(item.loc.end.line - 1, item.loc.end.column),\n  };\n}\n\nfunction functionOutline(\n  name: string,\n  params: Array<any>,\n  extent: Extent,\n): OutlineTree {\n  return {\n    kind: 'function',\n    tokenizedText: [\n      keyword('function'),\n      whitespace(' '),\n      method(name),\n      plain('('),\n      ...declarationsTokenizedText(params),\n      plain(')'),\n    ],\n    representativeName: name,\n    children: [],\n    ...extent,\n  };\n}\n\nfunction typeAliasOutline(typeAliasExpression: any): OutlineTree {\n  invariant(typeAliasExpression.type === 'TypeAlias');\n  const name = typeAliasExpression.id.name;\n  return {\n    kind: 'interface',\n    tokenizedText: [keyword('type'), whitespace(' '), type(name)],\n    representativeName: name,\n    children: [],\n    ...getExtent(typeAliasExpression),\n  };\n}\n\nfunction topLevelExpressionOutline(expressionStatement: any): ?OutlineTree {\n  switch (expressionStatement.expression.type) {\n    case 'CallExpression':\n      return specOutline(expressionStatement, /* describeOnly */ true);\n    case 'AssignmentExpression':\n      return moduleExportsOutline(expressionStatement.expression);\n    default:\n      return null;\n  }\n}\n\nfunction moduleExportsOutline(assignmentStatement: any): ?OutlineTree {\n  invariant(assignmentStatement.type === 'AssignmentExpression');\n\n  const left = assignmentStatement.left;\n  if (!isModuleExports(left)) {\n    return null;\n  }\n\n  const right = assignmentStatement.right;\n  if (right.type !== 'ObjectExpression') {\n    return null;\n  }\n  const properties: Array<Object> = right.properties;\n  return {\n    kind: 'module',\n    tokenizedText: [plain('module.exports')],\n    children: arrayCompact(properties.map(moduleExportsPropertyOutline)),\n    ...getExtent(assignmentStatement),\n  };\n}\n\nfunction isModuleExports(left: Object): boolean {\n  return (\n    left.type === 'MemberExpression' &&\n    left.object.type === 'Identifier' &&\n    left.object.name === 'module' &&\n    left.property.type === 'Identifier' &&\n    left.property.name === 'exports'\n  );\n}\n\nfunction moduleExportsPropertyOutline(property: any): ?OutlineTree {\n  invariant(property.type === 'Property');\n  if (property.key.type !== 'Identifier') {\n    return null;\n  }\n  const propName = property.key.name;\n\n  if (property.shorthand) {\n    // This happens when the shorthand `{ foo }` is used for `{ foo: foo }`\n    return {\n      kind: 'method',\n      tokenizedText: [string(propName)],\n      representativeName: propName,\n      children: [],\n      ...getExtent(property),\n    };\n  }\n\n  if (\n    property.value.type === 'FunctionExpression' ||\n    property.value.type === 'ArrowFunctionExpression'\n  ) {\n    return {\n      kind: 'method',\n      tokenizedText: [\n        method(propName),\n        plain('('),\n        ...declarationsTokenizedText(property.value.params),\n        plain(')'),\n      ],\n      representativeName: propName,\n      children: [],\n      ...getExtent(property),\n    };\n  }\n\n  return {\n    kind: 'field',\n    tokenizedText: [string(propName), plain(':')],\n    representativeName: propName,\n    children: [],\n    ...getExtent(property),\n  };\n}\n\nfunction specOutline(\n  expressionStatement: any,\n  describeOnly: boolean = false,\n): ?OutlineTree {\n  const expression = expressionStatement.expression;\n  if (expression.type !== 'CallExpression') {\n    return null;\n  }\n  const functionName = getFunctionName(expression.callee);\n  if (functionName == null) {\n    return null;\n  }\n  if (!isDescribe(functionName)) {\n    if (describeOnly || !isIt(functionName)) {\n      return null;\n    }\n  }\n  const description = getStringLiteralValue(expression.arguments[0]);\n  const specBody = getFunctionBody(expression.arguments[1]);\n  if (description == null || specBody == null) {\n    return null;\n  }\n  let children;\n  if (isIt(functionName)) {\n    children = [];\n  } else {\n    children = arrayCompact(\n      specBody\n        .filter(item => item.type === 'ExpressionStatement')\n        .map(item => specOutline(item)),\n    );\n  }\n  return {\n    kind: 'function',\n    tokenizedText: [method(functionName), whitespace(' '), string(description)],\n    representativeName: description,\n    children,\n    ...getExtent(expressionStatement),\n  };\n}\n\n// Return the function name as written as a string. Intended to stringify patterns like `describe`\n// and `describe.only` even though `describe.only` is a MemberExpression rather than an Identifier.\nfunction getFunctionName(callee: any): ?string {\n  switch (callee.type) {\n    case 'Identifier':\n      return callee.name;\n    case 'MemberExpression':\n      if (\n        callee.object.type !== 'Identifier' ||\n        callee.property.type !== 'Identifier'\n      ) {\n        return null;\n      }\n      return `${callee.object.name}.${callee.property.name}`;\n    default:\n      return null;\n  }\n}\n\nfunction isDescribe(functionName: string): boolean {\n  switch (functionName) {\n    case 'describe':\n    case 'fdescribe':\n    case 'ddescribe':\n    case 'xdescribe':\n    case 'describe.only':\n    case 'describe.skip':\n    case 'test.cb':\n    case 'test.serial':\n    case 'test.todo':\n    case 'test.failing':\n    case 'test':\n    case 'test.concurrent':\n    case 'test.only':\n    case 'test.skip':\n    case 'suite':\n    case 'suite.only':\n    case 'suite.skip':\n    case 'xtest':\n    case 'xtest.concurrent':\n    case 'xtest.only':\n    case 'xtest.skip':\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction isIt(functionName: string): boolean {\n  switch (functionName) {\n    case 'it':\n    case 'fit':\n    case 'iit':\n    case 'pit':\n    case 'xit':\n    case 'it.only':\n    case 'it.skip':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/** If the given AST Node is a string literal, return its literal value. Otherwise return null */\nfunction getStringLiteralValue(literal: ?any): ?string {\n  if (literal == null) {\n    return null;\n  }\n  if (literal.type !== 'Literal') {\n    return null;\n  }\n  const value = literal.value;\n  if (typeof value !== 'string') {\n    return null;\n  }\n  return value;\n}\n\nfunction getFunctionBody(fn: ?any): ?Array<any> {\n  if (fn == null) {\n    return null;\n  }\n  if (\n    fn.type !== 'ArrowFunctionExpression' &&\n    fn.type !== 'FunctionExpression'\n  ) {\n    return null;\n  }\n  return fn.body.body;\n}\n\nfunction variableDeclarationOutline(declaration: any): ?OutlineTree {\n  // If there are multiple var declarations in one line, just take the first.\n  return variableDeclaratorOutline(\n    declaration.declarations[0],\n    declaration.kind,\n    getExtent(declaration),\n  );\n}\n\nfunction variableDeclaratorOutline(\n  declarator: any,\n  kind: string,\n  extent: Extent,\n): ?OutlineTree {\n  if (\n    declarator.init != null &&\n    (declarator.init.type === 'FunctionExpression' ||\n      declarator.init.type === 'ArrowFunctionExpression')\n  ) {\n    return functionOutline(declarator.id.name, declarator.init.params, extent);\n  }\n\n  const {id} = declarator;\n\n  const tokenizedText = [\n    keyword(kind),\n    whitespace(' '),\n    ...declarationsTokenizedText([id]),\n  ];\n  const representativeName = id.type === 'Identifier' ? id.name : undefined;\n  return {\n    kind: kind === 'const' ? 'constant' : 'variable',\n    tokenizedText,\n    representativeName,\n    children: [],\n    ...extent,\n  };\n}\nfunction declareClassOutline(item: any, extent: Extent): ?OutlineTree {\n  const tokenizedText = [keyword('class')];\n  let representativeName = undefined;\n  if (item.id != null) {\n    tokenizedText.push(whitespace(' '), className(item.id.name));\n    representativeName = item.id.name;\n  }\n  const properties = item.body.properties;\n  return {\n    kind: 'class',\n    tokenizedText,\n    representativeName,\n    children: arrayCompact(properties.map(declareClassPropertyOutline)),\n    ...extent,\n  };\n}\nfunction declareClassPropertyOutline(item: any): ?OutlineTree {\n  if (item.key == null) {\n    return null;\n  }\n  const representativeName = item.key.name;\n  const extent = getExtent(item);\n  switch (item.value.type) {\n    case 'FunctionTypeAnnotation':\n      return functionOutline(representativeName, item.value.params, extent);\n    case 'StringTypeAnnotation':\n    case 'GenericTypeAnnotation':\n      return {\n        kind: 'property',\n        tokenizedText: [method(representativeName)],\n        representativeName,\n        children: [],\n        ...extent,\n      };\n    default:\n      return null;\n  }\n}\n\nfunction declareFunctionOutline(item: any, extent: Extent): ?OutlineTree {\n  const params = item.id.typeAnnotation.typeAnnotation.params;\n  return functionOutline(item.id.name, params.map(obj => obj.name), extent);\n}\nfunction declareModuleOutline(item: any, extent: Extent): ?OutlineTree {\n  const tokenizedText = [keyword('module')];\n  let representativeName = undefined;\n  if (item.id != null) {\n    tokenizedText.push(whitespace(' '), className(item.id.value));\n    representativeName = item.id.value;\n  }\n  return {\n    kind: 'interface',\n    tokenizedText,\n    representativeName,\n    children: itemsToTrees(item.body.body),\n    ...extent,\n  };\n}\nfunction declareVariableOutline(item: any, extent: Extent): ?OutlineTree {\n  return {\n    kind: 'variable',\n    tokenizedText: [keyword('var'), whitespace(' '), method(item.id.name)],\n    representativeName: item.id.name,\n    children: [],\n    ...extent,\n  };\n}\n"]}