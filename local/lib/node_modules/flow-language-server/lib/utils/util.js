'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filePathToURI = filePathToURI;
exports.fileURIToPath = fileURIToPath;
exports.hasFlowPragma = hasFlowPragma;
exports.flowSeverityToLSPSeverity = flowSeverityToLSPSeverity;
exports.lspPositionToAtomPoint = lspPositionToAtomPoint;
exports.atomPointToLSPPosition = atomPointToLSPPosition;
exports.atomRangeToLSPRange = atomRangeToLSPRange;
exports.lspRangeToAtomRange = lspRangeToAtomRange;
exports.compareLspPosition = compareLspPosition;
exports.compareLspRange = compareLspRange;

var _simpleTextBuffer = require('simple-text-buffer');

var _vscodeLanguageserverTypes = require('vscode-languageserver-types');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _nullthrows = require('nullthrows');

var _nullthrows2 = _interopRequireDefault(_nullthrows);

var _vscodeUri = require('vscode-uri');

var _vscodeUri2 = _interopRequireDefault(_vscodeUri);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

const FlowSeverity = {
  Error: 'Error',
  Warning: 'Warning'
};

const flowSeverityToLSPSeverityMap = {
  [FlowSeverity.Error]: _vscodeLanguageserverTypes.DiagnosticSeverity.Error,
  [FlowSeverity.Warning]: _vscodeLanguageserverTypes.DiagnosticSeverity.Warning
};

const FILE_PROTOCOL = 'file://';

// On Windows, vscode-uri converts drive paths to lowercase,
// which Flow doesn't like very much.
// We'll implement our own basic converters `filePathToURI` and
// `fileURIToPath`.

function filePathToURI(filePath) {
  if (process.platform !== 'win32') {
    return _vscodeUri2.default.file(filePath).toString();
  }

  return encodeURI(FILE_PROTOCOL + '/' + filePath.replace(/\\/g, '/'));
}

function fileURIToPath(fileUri) {
  if (process.platform !== 'win32') {
    return _vscodeUri2.default.parse(fileUri).fsPath;
  }

  (0, _assert2.default)(fileUri.startsWith(FILE_PROTOCOL), 'Must pass a valid file URI');

  let localPath = fileUri.slice(FILE_PROTOCOL.length);
  // Remove the leading slash and convert to backslashes.
  if (localPath.startsWith('/')) {
    localPath = localPath.substr(1);
  }
  return localPath.replace(/\//g, '\\');
}

function hasFlowPragma(content) {
  const hasPragma = content.startsWith('/* @flow */') || content.startsWith('// @flow\n') || /^\s*\/\*+\s*@flow\s*\*+\//m.test(content) || /^\s*\/\/\s*@flow\s*$/m.test(content);
  return hasPragma;
}

function flowSeverityToLSPSeverity(flowSeverity) {
  (0, _assert2.default)(flowSeverity === FlowSeverity.Warning || flowSeverity === FlowSeverity.Error, 'must be a valid flow severity');

  return (0, _nullthrows2.default)(flowSeverityToLSPSeverityMap[flowSeverity]);
}

function lspPositionToAtomPoint(lspPosition) {
  return new _simpleTextBuffer.Point(lspPosition.line, lspPosition.character);
}

function atomPointToLSPPosition(atomPoint) {
  return {
    line: atomPoint.row,
    character: atomPoint.column
  };
}

function atomRangeToLSPRange(atomRange) {
  return {
    start: atomPointToLSPPosition(atomRange.start),
    end: atomPointToLSPPosition(atomRange.end)
  };
}

function lspRangeToAtomRange(lspRange) {
  return {
    start: lspPositionToAtomPoint(lspRange.start),
    end: lspPositionToAtomPoint(lspRange.end)
  };
}

function compareLspPosition(a, b) {
  return a.line - b.line || a.character - b.character;
}

function compareLspRange(a, b) {
  return compareLspPosition(a.start, b.start) || compareLspPosition(a.end, b.end);
}
//# sourceMappingURL=util.js.map