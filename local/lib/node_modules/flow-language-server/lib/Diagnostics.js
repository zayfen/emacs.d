'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator = require('async-to-generator');

var _asyncToGenerator2 = _interopRequireDefault(_asyncToGenerator);

var _collection = require('nuclide-commons/collection');

var _FlowSingleProjectLanguageService = require('./pkg/nuclide-flow-rpc/lib/FlowSingleProjectLanguageService');

var _util = require('./utils/util');

var _log4js = require('log4js');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const logger = (0, _log4js.getLogger)('Diagnostics'); /**
                                                       * Copyright (c) 2017-present, Facebook, Inc.
                                                       * All rights reserved.
                                                       *
                                                       * This source code is licensed under the BSD-style license found in the
                                                       * LICENSE file in the root directory of this source tree. An additional grant
                                                       * of patent rights can be found in the PATENTS file in the same directory.
                                                       *
                                                       * 
                                                       * @format
                                                       */

class Diagnostics {

  constructor({ flow }) {
    this.flow = flow;
  }

  diagnoseOne(document) {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const emptyDiagnostic = {
        uri: document.uri,
        diagnostics: []
      };

      const documentPath = (0, _util.fileURIToPath)(document.uri);
      if (!documentPath) {
        return [];
      }

      const diagnostics = yield _this.flow.getDiagnostics(documentPath, document.buffer);

      if (diagnostics == null || diagnostics.size === 0) {
        // clear out any old diagnostics by sending an explicit empty list of
        // diagnostics
        return [emptyDiagnostic];
      }

      return Array.from(diagnostics.entries()).map(fileDiagnosticUpdateToLSPDiagnostic);
    })();
  }

  observe() {
    logger.info('Beginning to observe diagnostics');

    return this.flow.observeDiagnostics().map(diagnostics => Array.from(diagnostics.entries()).map(
    // $FlowFixMe
    fileDiagnosticUpdateToLSPDiagnostic));
  }
}

exports.default = Diagnostics;
function fileDiagnosticUpdateToLSPDiagnostic([filePath, flowDiagnostics]) {
  return {
    uri: (0, _util.filePathToURI)(filePath),
    diagnostics: flowDiagnostics.filter(d => d.range != null).map(diagnostic => {
      const relatedLocations = (0, _collection.arrayCompact)((diagnostic.trace || []).map(atomTrace_lspRelatedLocation));

      (0, _assert2.default)(diagnostic.range != null);
      return {
        range: (0, _util.atomRangeToLSPRange)(diagnostic.range),
        severity: (0, _util.flowSeverityToLSPSeverity)(diagnostic.type),
        source: diagnostic.providerName,
        relatedInformation: relatedLocations,
        message: relatedLocations.length === 0 ? toMessage(diagnostic) : diagnostic.text || ''
      };
    })
  };
}

/**
 * From Nuclide's convert.js
 *
 * Converts an Atom Trace to an Lsp RelatedLocation. A RelatedLocation requires a
 * range. Therefore, this will return null when called with an Atom Trace that
 * does not have a range.
 */
function atomTrace_lspRelatedLocation(trace) {
  const range = trace.range,
        text = trace.text,
        filePath = trace.filePath;

  if (range != null) {
    return {
      message: text || '',
      location: {
        uri: (0, _util.filePathToURI)(filePath),
        range: (0, _util.atomRangeToLSPRange)(range)
      }
    };
  }
  return null;
}

// transform legacy diagnostics (without relatedLocations) into a more verbose
// description
function toMessage(diagnostic) {
  let message = diagnostic.text || '';
  if (diagnostic.trace && diagnostic.trace.length) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = diagnostic.trace[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const trace = _step.value;

        if (trace.text != null) {
          // put new 'sentences' on their own line
          // $FlowFixMe text presence is asserted above
          if (trace.text[0] && trace.text[0] === trace.text[0].toUpperCase()) {
            message += '\n';
          } else {
            message += ' ';
          }
          message += trace.text;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return message;
}
//# sourceMappingURL=Diagnostics.js.map